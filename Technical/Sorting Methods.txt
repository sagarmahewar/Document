{\rtf1\ansi\ansicpg1252\cocoartf1265
{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs24 \cf0 SIMPLE SORT\
\
Insertion Sort - \
\
If larger, it leaves the element in place and moves to the next. If smaller, it finds the correct position within the sorted list, shifts all the larger values up to make a space, and inserts into that correct position.\
\
Example: The following table shows the steps for sorting the sequence \{3, 7, 4, 9, 5, 2, 6, 1\}. In each step, the item under consideration is underlined. The item that was moved (or left in place because it was biggest yet considered) in the previous step is shown in bold.\
\
3 7 4 9 5 2 6 1\
3 7 4 9 5 2 6 1\
3 4 7 9 5 2 6 1\
3 4 7 9 5 2 6 1\
3 4 5 7 9 2 6 1\
2 3 4 5 7 9 6 1\
2 3 4 5 6 7 9 1\
1 2 3 4 5 6 7 9\
\
\
Selection Sort -\
\
The idea of selection sort is rather simple: we repeatedly find the next largest (or smallest) element in the array and move it to its final position in the sorted array. Assume that we wish to sort the array in increasing order, i.e. the smallest element at the beginning of the array and the largest element at the end. We begin by selecting the largest element and moving it to the highest index position. We can do this by swapping the element at the highest index and the largest element. We then reduce the effective size of the array by one element and repeat the process on the smaller (sub)array. The process stops when the effective size of the array becomes 1 (an array of 1 element is already sorted).\
\
For example, consider the following array, shown with array elements in sequence separated by commas:\
\
63,  75,  90,  12,  27\
\
The leftmost element is at index zero, and the rightmost element is at the highest array index, in our case, 4 (the effective size of our array is 5). The largest element in this effective array (index 0-4) is at index 2. We have shown the largest element and the one at the highest index in bold. We then swap the element at index 2 with that at index 4. The result is:\
\
63,  75,  27,  12,  90\
\
We reduce the effective size of the array to 4, making the highest index in the effective array now 3. The largest element in this effective array (index 0-3) is at index 1, so we swap elements at index 1 and 3 (in bold):\
\
63,  12,  27,  75,  90\
\
The next two steps give us:\
\
27,  12,  63,  75,  90\
12,  27,  63,  75,  90\
\
The last effective array has only one element and needs no sorting. The entire array is now sorted. The algorithm for an array, x, with lim elements is easy to write down:\
\
\
EFFICIENT SORT\
\
Merge Sort\
\
Merge sort takes advantage of the ease of merging already sorted lists into a new sorted list. It starts by comparing every two elements (i.e., 1 with 2, then 3 with 4...) and swapping them if the first should come after the second. It then merges each of the resulting lists of two into lists of four, then merges those lists of four, and so on; until at last two lists are merged into the final sorted list.\
\
\
\
Heap Sort\
\
Quick Sort :\
\
The steps are:\
-Pick an element, called a pivot, from the list.\
-Reorder the list so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.\
-Recursively apply the above steps to the sub-list of elements with smaller values and separately the sub-list of elements with greater values.\
\
Input: [13 81 92 65 43 31 57 26 75 0]\
Pivot: 65\
Partition:  [13 0 26 43 31 57]  65  [ 92 75 81]\
Pivot: 31  81  \
Partition: [13 0 26]  31  [43 57]  65  [75]  81  [92]\
Pivot: 13\
Partition: [0]  13  [26]  31  [43 57]  65  [75]  81  [92]\
Combine: [0 13 26]  31 [43 57]  65  [75 81 92]\
Combine: [0 13 26 31 43 57]  65  [75 81 92]\
Combine: [0 13 26 31 43 57 65 75 81 92]\
\
\
\
BUBBLE SORT & VARIANT\
\
Bubble Sort\
\
Let us take the array of numbers "5 1 4 2 8", and sort the array from lowest number to greatest number using bubble sort. In each step, elements written in bold are being compared. Three passes will be required.\
First Pass:\
( 5 1 4 2 8 ) \\to ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1.\
( 1 5 4 2 8 ) \\to ( 1 4 5 2 8 ), Swap since 5 > 4\
( 1 4 5 2 8 ) \\to ( 1 4 2 5 8 ), Swap since 5 > 2\
( 1 4 2 5 8 ) \\to ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.\
Second Pass:\
( 1 4 2 5 8 ) \\to ( 1 4 2 5 8 )\
( 1 4 2 5 8 ) \\to ( 1 2 4 5 8 ), Swap since 4 > 2\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.\
Third Pass:\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
( 1 2 4 5 8 ) \\to ( 1 2 4 5 8 )\
\
}{\*\shppict {\pict \jpegblipPageWidth pageWidth = 494.199982}}{\*\shppict {\pict \jpegHeaderFooterString headerStyle = 0, headerPageFormat = 0, headerStartNumber = 0, headerIncludeNumberOnFirstPage = 0, footerStyle = 0, footerPageFormat = 0, footerStartNumber = 0, footerIncludeNumberOnFirstPage = 0,}}