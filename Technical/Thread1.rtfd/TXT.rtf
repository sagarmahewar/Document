{\rtf1\ansi\ansicpg1252\cocoartf1265
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fswiss\fcharset0 ArialMT;\f2\fnil\fcharset0 Consolas;
\f3\fswiss\fcharset0 Helvetica;\f4\fnil\fcharset0 Consolas-Italic;}
{\colortbl;\red255\green255\blue255;\red253\green134\blue8;\red14\green14\blue14;\red133\green0\blue2;
\red0\green0\blue255;\red250\green234\blue173;\red109\green109\blue109;\red8\green68\blue111;\red15\green112\blue1;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1008\margr1008\margt1008\vieww25400\viewh13320\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs24 \cf0 1] As far as Windows is concerned, all threads are alike. MFC, however, distinguishes between two types of threads: user interface (UI) threads and worker threads.\
\
2] The difference between the two is that UI threads have message loops and worker threads don't. UI threads can create windows and process messages sent to those windows. Worker threads perform background tasks that receive no direct input from the user and therefore don't need windows and message loops.\
\
3] The best way to launch a thread in an MFC application is to call AfxBeginThread. MFC defines two different versions of AfxBeginThread: one that starts a UI thread and another that starts a worker thread. AfxBeginThread creates a new CWinThread object, launches a thread and attaches it to the CWinThread object, and returns a CWinThread pointer. The statement\
\
CWinThread* pThread = AfxBeginThread (ThreadFunc, &threadInfo);\
\
4] starts a worker thread and passes it the address of an application-defined data structure (&threadInfo) that contains input to the thread. ThreadFunc is the thread function\uc0\u151 the function that gets executed when the thread itself begins to execute. A very simple thread function that spins in a loop eating CPU cycles and then terminates looks like this:\
\
UINT ThreadFunc (LPVOID pParam)\
\{\
    UINT nIterations = (UINT) pParam;\
    for (UINT i=0; i<nIterations; i++);\
    return 0;\
\}\
\
5] The worker thread form of AfxBeginThread accepts as many as four additional parameters that specify the thread's priority, stack size, creation flags, and security attributes. \
\
CWinThread* AfxBeginThread (AFX_THREADPROC pfnThreadProc,\
    LPVOID pParam, int nPriority = THREAD_PRIORITY_NORMAL,\
    UINT nStackSize = 0, DWORD dwCreateFlags = 0,\
    LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL)\
\
-nPriority specifies the thread's execution priority. nPriority doesn't specify an absolute priority level. It specifies a priority level relative to the priority level of the process to which the thread belongs. The default is THREAD_PRIORITY_NORMAL, You can change a thread's priority level at any time with CWinThread::SetThreadPriority.\
\
-The nStackSize parameter passed to AfxBeginThread specifies the thread's maximum stack size. In the Win32 environment, each thread receives its own stack. The 0 default nStackSize value allows the stack to grow as large as 1 MB. This doesn't mean that every thread requires a minimum of 1 MB of memory; it means that each thread is assigned 1 MB of address space in the larger 4-GB address space in which 32-bit Windows applications execute. \
\
-dwCreateFlags can be one of two values. The default value 0 tells the system to start executing the thread immediately. If CREATE_SUSPENDED is specified instead, the thread starts out in a suspended state and doesn't begin running until another thread (usually the thread that created it) calls CWinThread::ResumeThread on the suspended thread, as demonstrated here:\
\
CWinThread* pThread = AfxBeginThread (ThreadFunc, &threadInfo, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);            \
pThread->ResumeThread (); // Start the thread\
\
Sometimes it's useful to create a thread but defer its execution until later. The CREATE_SUSPENDED flag is your mechanism for enacting delayed execution.\
\
-lpSecurityAttrs, is a pointer to a SECURITY_ATTRIBUTES structure that specifies the new thread's security attributes and also tells the system whether child processes should inherit the thread handle. The NULL default value assigns the new thread the same properties the thread that created it has.\
\
6] Suspending and Resuming Threads :\
A running thread can be suspended with CWinThread::SuspendThread and started again with CWinThread::ResumeThread. A thread can call SuspendThread on itself, or another thread can call SuspendThread for it. However, a suspended thread can't call ResumeThread to wake itself up;\
\
------------------------------------------------------------------------------------------------------\
\
WaitForSingleObject\
\
DWORD WINAPI WaitForSingleObject(\
  _In_  HANDLE hHandle,\
  _In_  DWORD dwMilliseconds\
);\
\
hHandle -\
A handle to the object. If this handle is closed while the wait is still pending, the function's behavior is undefined.\
The handle must have the SYNCHRONIZE access right.\
\
dwMilliseconds -\
The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.\
 \
Return value -\
\
If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.\
\
\
WAIT_ABANDONED : The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.\
If the mutex was protecting persistent state information, you should check it for consistency.\
\
WAIT_OBJECT_0 : The state of the specified object is signaled.\
\
WAIT_TIMEOUT : The time-out interval elapsed, and the object's state is nonsignaled.\
\
WAIT_FAILED : The function has failed. To get extended error information, call GetLastError.\
\
------------------------------------------------------------------------------------------------------\
\
ThreadPool\
\
What is ThreadPool?\
Thread Pool is collection of Live, Reusable threads. \
 \
Why ThreadPool?\
There are many situation where we can use ThreadPool. Consider a Client-Server application in which server has to respond to multiple client at same time. This means multitasking. Server will need a set of certain no. of threads which will do reply to client.\
The big advantage of thread pool is that, it provides reusable thread. Though thread creation is very bulky process. It increases overhead. Suppose a new client send some data to server and Server has to respond. What will server do? It will create a new thread which will send data to client and then get killed or exited. Instead of creating thread on each client request we can keep collection of live thread. We will use any free thread which will send data to client. By that we will save a great overhead generated by creating threads multiple times. ...\
 \
\
/****************************************************************************\
CThreadPoolMgr Initialize \
Description : Creates threads. Thread limit is 5\
****************************************************************************/\
void CThreadPoolMgr::Initialize(int nThread)\
\{\
    m_nThreadCount = nThread;\
 \
    int nCounter = 0;\
    int nThreadCount = m_nThreadCount - 1;\
    \
    while( nCounter <= nThreadCount )\
    \{\
        // Create objects in heap\
        m_ptrCThread[nCounter] = new CThread();\
 \
        m_ptrCThread[nCounter]->CreateWorkerThread();\
        m_hThreadPool[nCounter] = m_ptrCThread[nCounter]->GetThreadHandle();\
        // Increment the counter\
        nCounter++;\
    \}    \
\}\
 \
\
 \
/****************************************************************************\
CThreadPoolMgr ShutDown \
Description : Mark shutdown siganl and wait for each thread to end \
****************************************************************************/\
void CThreadPoolMgr::ShutDown()\
\{\
    int Count = 0;\
 \
    while(Count <= (m_nThreadCount - 1))\
    \{\
        m_ptrCThread[Count]->SignalShutDownEvent();\
        \
        Count++;\
    \}\
 \
    // Check if all threads ended successfully\
    DWORD dwWaitResult = WaitForMultipleObjects( GetThreadCount(), m_hThreadPool, TRUE, INFINITE);\
    \
    switch(dwWaitResult)\
    \{\
    case WAIT_OBJECT_0:\
        \{\
            cout << "All threads are ended.\\n";\
            // Close all handles \
            Count = 0;\
            while( Count <= (m_nThreadCount - 1))\
            \{\
                m_ptrCThread[Count]->ReleaseHandles();\
                delete m_ptrCThread[Count];\
                Count++;\
            \}\
            \
            break;\
        \}\
 \
    default:\
        cout << "Wait Error: " << GetLastError() << "\\n";\
    \}\
    \
\}\
\
What is DeadLock\
\
\pard\pardeftab720\sa273

\f1\i\fs28 \cf0 "Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Here's an example. Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time."\
What is Race Condition\

\i0 A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.\
\
\pard\pardeftab720\sa220

\fs36 \cf2 Thread Safety Issue for Singletons
\fs60 \
\pard\pardeftab720\sa280

\fs28 \cf3 Remember, thread-safety issue for Singletons would occur only rarely, as follows (rarely, but still catastrophic! so you still need to design for it):\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf3 {\listtext	1.	}No client code has called 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3  so far, and now two threads simultaneously call 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3 , and\
{\listtext	2.	}Context switch between the two calling threads happen on the exact line of code at:\
\pard\tx566\pardeftab720

\f2\fs24 \cf5 \cb6 \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0\cf5          if\cf0  (m_pOnlyOneInstance == NULL)
\f1\fs28 \cf3 \cb1 \
\pard\pardeftab720\sa280
\cf3 During further calls to 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3 , the 
\f2\fs30 \cf4 MySingleton
\f1\fs28 \cf3  object is already created and would be returned. But it's still a serious issue, as we've instantiated 
\f2\fs30 \cf4 MySingleton
\f1\fs28 \cf3  twice.\
\pard\pardeftab720\sa380

\fs38 \cf2 Solution\
\pard\pardeftab720\sa280

\fs28 \cf3 We can achieve good performance and lazy instantiation for Singletons (which were the short-comings of Solutions 1 and 2 for the short-term memory loss readers out there).\
You can achieve this by moving around code in Solution 1.\
Do go back to Solution 1 and think about how this can be done before proceeding further.\
\pard\pardeftab720\sa40

\b \cf7 Deep Dive into Solution 3\
\pard\pardeftab720\qr

\f3\b0\fs24 \cf0 {{\NeXTGraphic minus.gif \width180 \height180 \noorient
}¬}\pard\pardeftab720\qr

\f1\fs22 \cf8  Collapse | Copy Code\
\pard\pardeftab720

\f2\fs24 \cf0 \cb6 MySingleton * GetInstance()\
\{\
      \cf5 if\cf0  (m_pOnlyOneInstance == NULL)\
      \{\
            EnterCriticalSection();\
            \cf5 if\cf0  (m_pOnlyOneInstance == NULL)\
            
\f4\i \cf9 // Solution 1 and 2 gaps addressed by moving\

\f2\i0 \cf0             
\f4\i \cf9 // critical section block and by re-doing this check!\

\f2\i0 \cf0             \{\
                  m_pOnlyOneInstance = \cf5 new\cf0  MySingleton();\
            \}\
            LeaveCriticalSection();\
      \}\
      \cf5 return\cf0  m_pOnlyOneInstance;\
\}\
\pard\pardeftab720\sa280

\f1\fs28 \cf3 \cb1 With Solution 3, you do not use a critical section every time a client calls 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3 , and we achieve Lazy Instantiation. The 
\f2\fs30 \cf4 MySingleton
\f1\fs28 \cf3  object is created only when the client calls 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3 .\
Also, a Critical Section is used only during instantiation, and for handling the rare (but catastrophic!) thread-safety issue during instantiation and the race condition between two threads.\'a0We do not enter a critical section block every time the client calls 
\f2\fs30 \cf4 GetInstance()
\f1\fs28 \cf3 .\
Congratulations! You\'92ve just learnt Double-Checked Locking, the formal name for Solution 3.\
\cf0 \
}