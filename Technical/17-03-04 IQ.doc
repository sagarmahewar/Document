{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Calibri;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red191\green191\blue191;\red192\green192\blue192;\red10\green82\blue135;
\red109\green109\blue109;\red249\green249\blue249;\red9\green78\blue192;\red0\green0\blue233;\red38\green38\blue38;
\red254\green224\blue207;\red28\green28\blue28;\red9\green47\blue157;\red67\green67\blue67;\red245\green245\blue245;
\red255\green255\blue0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
{\info
{\keywords cursorLocation=83430}}\vieww25600\viewh14160\viewkind0\viewscale181
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs16 \cf0 STL \'96 Array, Vector, Map, List differences\
\
The C++ Interview \
\
These 40 questions and answers will help you land the assignment\
\
by Alex Bykov\
\
How do you rank your C++ skills on a scale of 1 to 10? \
\
This is often the first question you will hear on an interview for a C++ contract. You will be tempted to rate yourself high, and you should. This is your chance to convince the client that you are just what he is looking for -- an assertive and knowledgeable professional who will be productive either working on a team or on your own. Naturally, though, you should be able to support the ranking you gave yourself by doing well on the interview. This article will help you prepare for your C++ interview. \
\
I put together a list of 40 questions that I have had to answer during numerous technical interviews in the past few years. You, too, will have to answer at least some of them during an interview. Even if you use C++ on a daily basis, it pays to go through the questions. Most of us, no matter how experienced, use only a segment of the language that we are most comfortable with. Brief answers are included, but you can find more information in the references listed. \
\
Q1. Is there anything you can do in C++ that you cannot do in C? \
A1. No. There is nothing you can do in C++ that you cannot do in C. After all you can write a C++ compiler in C. \
\
\
Q2. What is the difference between C++ structure and C++ class? \
A2. The default access level assigned to members of struct is public while the default access level assigned to a class is private. \
\
Q3. What is encapsulation? \
A3. Encapsulation is welding of code and data together into objects.\
\
Q4. What is inheritance? \
A4. Inheritance is a mechanism through which a subclass inherits the properties and behavior of its superclass. \
\
Q5. What is polymorphism? \
A5. In Greek this means "many shapes." As a consequence of inheritance and virtual functions, a single task (for example, drawing a geometrical shape) can be implemented using the same name (like draw()) and implemented differently (via virtual functions) as each type in object hierarchy requires(circle.draw() or rectangle.draw()). Later, when a polymorphic object (whose type is not known at compile time) executes the draw() virtual function, the correct implementation is chosen and executed at run time. \
\
Using the same thing in different way is know as Polymorphism.\
\
Types of Polymorphism : \
1] Static Polymorphism \'96 Template, Function Overloading & Operator Overloading.\
2] Dynamic Polymorphism \'96 Inheritance & Virtual Functions\
\
run-time: \
The run-time polymorphism is implemented with inheritance and virtual functions. \
compile-time: \
The compile-time polymorphism is implemented with templates. \
ad-hoc polymorphism: \
If the range of actual types that can be used is finite and the combinations must be individually specified prior to use, this is called ad-hoc polymorphism. \
parametric polymorphism: \
If all code is written without mention of any specific type and thus can be used transparently with any number of new types it is called parametric polymorphism. \
\
\
Q6. What would you say if you saw "delete this" while reviewing your peer's code? \
A6. You should never do this. Since compiler does not know whether the object was allocated on the stack or on the heap, "delete this" could cause a disaster. \
\
Q7. What is the difference between public, protected, and private members of a class? \
A7. Private members are accessible only by members and friends of the class. Protected members are accessible by members and friends of the class and by members and friends of derived classes. Public members are accessible by everyone. \
\
\
Q8. What is the difference between non-virtual and virtual functions? \
A8. The behavior of a non-virtual function is known at compile time while the behavior of a virtual function is not known until the run time. \
\
Q9. What is a pure virtual function? \
A9. It is a member function without implementation. It can have definition to use by derived class overridden inherited functions\
\
Q10. What is an abstract base class? \
A10. It is a class that has one or more pure virtual functions. \
\
Q11. What is the difference between MyClass p; and MyClass p();? \
A11. MyClass p; creates an instance of class MyClass by calling a constructor for MyClass. MyClass p(); declares function p which takes no parameters and returns an object of class MyClass by value. \
\
Q12. How do you know that your class needs a virtual destructor? \
A12. If your class has at least one virtual function, you should make a destructor for this class virtual. This will allow you to delete a dynamic object through a pointer to a base class object. If the destructor is non-virtual, then wrong destructor will be invoked during deletion of the dynamic object. \
\
Q13. Why were the templates introduced? \
A13. Many data structures and algorithms can be defined independently of the type of data they work with. You can increase the amount of shared code by separating data-dependent portions from data-independent portions, and templates were introduced to help you do that. \
\
Q14. What is a static member of a class? \
A14. Static data members exist once for the entire class, as opposed to non-static data members, which exist individually in each instance of a class. \
\
Q15. What feature of C++ would you use if you wanted to design a member function that guarantees to leave "this\'d3 object unchanged? \
A15. It is "const" as in: "int MyFunc (int test) const;" \
\
Q16. Can you overload a function based only on whether a parameter is a value or a reference? \
A16. No. Passing by value and by reference looks identical to the caller. \
\
Q17. What is the difference between function overloading and function overriding? \
A17. Overloading is a method that allows defining multiple member functions with the same name but different signatures. The compiler will pick the correct function based on the signature. Overriding is a method that allows the derived class to redefine the behavior of member functions which the derived class inherits from a base class. The signatures of both base class member function and derived class member function are the same; however, the implementation and, therefore, the behavior will differ. \
\
Q18. Can derived class override some but not all of a set of overloaded virtual member functions inherited from the base class? \
A18. Compiler will allow this, but it is a bad practice since overridden member functions will hide all of the inherited overloads from the base class. You should really override all of them. \
\
Q19. What is the difference between assignment and initialization in C++? \
A19. Assignment changes the value of the object that has already been constructed. Initialization constructs a new object and gives it a value at the same time. \
\
Q20. When is  copy constructors called? \
A20. Copy constructors are called in three cases: when a function returns an object of that class by value, when the object of that class is passed by value as an argument to a function, and, finally, when you construct an object based on another object of the same class (Circle c1=c2;). \
\
Q21. Why do you have to provide your own copy constructor and assignment operator for classes with dynamically allocated memory? \
A21. If you don't, the compiler will supply and execute the default constructor and the assignment operator, but they will not do the job correctly. The default assignment operator does member wise assignment and the default copy constructor does member wise copy. In both cases you will only assign and manipulate pointers to dynamic memory, which will lead to memory leaks and other abnormalities. You should write your own assignment operator and copy constructor, which would copy the pointer to memory so that each object has its own copy. \
\
Q22. Does compiler guarantee that initializers will be executed in the same order as they appear on the initialization list? \
A22. No. C++ guarantees that base class sub objects and member objects will be destroyed in the opposite order from which they were constructed. This means that initializers are executed in the order, which supports the above-mentioned guarantee. \
\
Q23. What is function's signature? \
A23. Function's signature is its name plus the number and types of the parameters it accepts.\
\
Q24. What does extern "C" int func(int *, Foo) accomplish? \
A24. It will turn off "name mangling" for this function so that one can link to code compiled by C compiler. \
[Whenever you compile code on C++ compiler which was already compiled on C compiler then it raises error of Name Mangling, above style is solution for that error.]\
\
Q25. Why do C++ compilers need name mangling? \
A25. Name mangling is the rule according to which C++ changes function's name into function signature before passing that function to a linker. This is how the linker differentiates between different functions with the same name. \
\
** Then how it clears the name mangling problem with extern \'93C\'94\
--It just turn off  \'93Name mangling\'94 for this function. \
\
? Then how it differentiate between different function with same name.\
--Because in C you do not support the FUNCTION OVERLOADING as a feature, so no need of Name Mangling.\
\
Q26. What is the difference between a pointer and a reference? \
A26. A reference must always refer to some object and, therefore, must always be initialized; pointers do not have such restrictions. A pointer can be reassigned to point to different objects while a reference always refers to an object with which it was initialized.\
\
Q27. How can you access the static member of a class? \
A27. <ClassName>::<StaticMemberName>. \
\
Q28. How are prefix and postfix versions of operator++() differentiated? \
A28. The postfix version of operator++() has a dummy parameter of type int. The prefix version does not have dummy parameter. \
\
Q29. What functions does C++ silently write and call? \
A29. Constructors, destructors, copy constructors, assignment operators, and address-of operators. \
\
Q30. What is the difference between new/delete and malloc/free?\
A30. Malloc/free do not know about constructors and destructors. New and delete create and destroy objects, while malloc and free allocate and deallocate memory. \
\
Q31. What is the difference between delete and delete[ ]? \
A31. Delete deletes one object; delete[ ] deletes an array of objects. \
\
Q32. Name two cases where you MUST use initialisation list as opposed to assignment in constructors. \
A32. Both non-static const data members and reference data members cannot be assigned values; instead, you should use initialisation list to initialise them. \
\
Q33. What is the difference between const char *myPointer and char *const myPointer? \
A33. Const char *myPointer is a non constant pointer to constant data; while char *const myPointer is a constant pointer to non constant data. \
\
Q34. Suppose that objects A, B, and C are instances of class MyClass (MyClass A, B, C;). How should you design an assignment operator so that the "A=B=C;" statement would be allowed by a compiler but "(A=B)=C;" would not be allowed by a compiler? \
A34. Make operator=return a reference to a const object. \
\
Q35. Is there any problem with the following: char *a=NULL; char& p = *a;? \
A35. The result is undefined. You should never do this. A reference must always refer to some object. \
\
Q36. Class B is derived from class A. Function f is A's friend. Is f B's friend as well? \
A36. No. Friendship cannot be inherited.\
\
Q37. What issue do auto_ptr objects address? \
A37. If you use auto_ptr objects you would not have to be concerned with heap objects not being deleted even if the exception is thrown. auto_ptr is a smart pointer class template.\
\
Q38. What happens when a function throws an exception that was not specified by an exception specification for this function? \
A38. Unexpected() is called, which, by default, will eventually trigger abort(). \
\
Q39. Why should you prefer throw/catch mechanism to setjmp/longjmp? \
A39. The main problem with longjmp() is that it does not destroy local objects properly. \
- Setjmp and longjmp should not be used in C++. \
- Longjmp jumps out of the function without unwinding the stack. This means that the local objects generated are not destructed properly. \
- The better option is to use try/catch/throw instead. They properly destruct the local objects.\
\
Q40. Can you think of a situation where your program would crash without reaching the breakpoint which you set at the beginning of main()?\
A40. C++ allows for dynamic initialization of global variables before main() is invoked. It is possible that initialization of global will invoke some function. If this function crashes the crash will occur before main() is entered. \
\
Q41. cout/cin are object which class ?\
A41. cout is object of ostream_withassign and cin is object of istream_withassign.\
[ios -> istream/ostream -> ostream_withassign/ istream_withassign]\
\
Q42. What is void *\
A42.  In C and C++, any time you need a void pointer, you can use another pointer type. For example, if you have \
a char*, you can pass it to a function that expects a void*. You don\'92t even need to cast it. In C (but not \
in C++), you can use a void* any time you need any kind of pointer, without casting. (In C++, you need to \
cast it). \
\
\
Q43. What is callback function\
A43. The simple answer to this first question is that a callback function is a function that is called through a function pointer. If you pass the pointer (address) of a function as an argument to another, when that pointer is used to call the function it points to it is said that a call back is made.\
\
Q44.This one could be easily become one of the  HYPERLINK "http://www.dev102.com/tag/job-interview/" Job Interview Questions we publish here at  HYPERLINK "http://www.dev102.com/" Dev102.com, but I decided to write a \'93regular\'94 post about this issue because it is an important concept and not a just a puzzle or a brain teaser. Take a look at the following code, can you tell what will the output be?\
public class BaseType\
 \{\
     public BaseType()\
     \{\
         Console.WriteLine("Call base ctor.");\
         DoSomething();\
     \}\
\
     public virtual void DoSomething()\
     \{\
         Console.WriteLine("Base DoSomething");\
     \}\
 \}\
\
 public class DerivedType : BaseType\
 \{\
     public DerivedType()\
     \{\
         Console.WriteLine("Call derived ctor.");\
     \}\
\
     public override void DoSomething()\
     \{\
         Console.WriteLine("Derived DoSomething");\
     \}\
 \}\
\
 public class MainClass\
 \{\
     public static void Main()\
     \{\
         DerivedType derived = new DerivedType();\
         Console.ReadLine();\
     \}\
 \}\
The output of this program is:\
Call base ctor.\
Derived DoSomething\
Call derived ctor.\
Can you see the problem here? There is something very wrong and dangerous in this code\'85 \
Explanation: When constructing the derived class, the base class is constructed first. If you call a virtual method from the base class constructor, the overridden method is called. But notice that when that overridden method is called, the derived class is not initialized because its constructor code was not executed yet. So, we are calling a method of an un-initialized instance\'85 This is the explanation from MSDN: \'93When a virtual method is called, the actual type that executes the method is not selected until run time. When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed\'93.\
Be aware of this matter because it is not a trivial issue and apparently, there are no errors or warnings generated by the compiler. So, the rule to remember is to never call virtual methods from constructors. Now, go and check your code, is there a possibility that you violated this rule?\
\
Q45. Consider the Differences Between the 32-bit and 64-bit Data Models\
The biggest difference between the 32-bit and the 64-bit compilation environments is the change in data-type models. The C data-type model for 32-bit applications is the ILP32 model, so named because the int and long types, and pointers, are 32-bit data types. The data-type model for 64-bit applications is the LP64 data model, so named because long and pointer types grow to 64 bits. The remaining C integer types and the floating-point types are the same in both data-type models. \
It is not unusual for current 32-bit applications to assume that the int type, long type, and pointers are the same size. Because the size of long and pointer change in the LP64 data model, this change alone is the principal cause of ILP32-to-LP64 conversion problems. \
? What problem 32 bit to 64 bit porting can cause \
\
Q46.  HYPERLINK "http://stackoverflow.com/questions/399003/is-the-sizeofsome-pointer-always-equal-to-four" Is the sizeof(some pointer) always equal to four?\
In practice, pointers will be size 2 on a 16-bit system (if you can find one), 4 on a 32-bit system, and 8 on a 64-bit system, but there's nothing to be gained in relying on a given size.\
\
Q47. Given only a pointer to a node to be deleted in a singly linked list, how do you delete it?\
The solution to this is to copy the data from the next node into this node and delete the next node!. Of course this wont work if the node to be deleted is the last node. Mark it as dummy in that case.\
\
Q.48 Difference between Dynamic Array & Linked List\
Ans : - \
[Insertion & Deletion] At Linked list insertion of an element at a specific point of a list is a constant-time operation, whereas insertion in a dynamic array at random locations will require moving half of the elements on average, and all the elements in the worst case. While one can "delete" an element from an array in constant time by somehow marking its slot as "vacant", this causes fragmentation that impedes the performance of iteration.\
[Access] On the other hand, dynamic arrays "Array data structure" allow constant-time "Random access", while linked lists allow only "Sequential access" to elements.\
[Extra storage for references] Another disadvantage of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data items such as characters or boolean values, because the storage overhead for the links may exceed by a factor of two or more the size of the data. In contrast, a dynamic array requires only the space for the data itself\
\
Q.49 Types of linked list: \
There are different kinds of linked lists they are \
\
Linear singly linked list \
Singly linked lists contain nodes which have a data field as well as a next field, which points to the next node in line.\
\
Circular singly linked list \
In the last node of a list, the link field often contains a null reference, a special value used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case the list is said to be circular or circularly linked; otherwise it is said to be open or linear.\
\
Two way or doubly linked list \
In a doubly linked list, each node contains, besides the next-node link, a second link field pointing to the previous node in the sequence. The two links may be called forward(s) and backwards, or next and prev(ious).\
\
Circular doubly linked list. \
\
Sentinel nodes\
In some implementations, an extra sentinel or dummy node may be added before the first data record and/or after the last one. This convention simplifies and accelerates some list-handling algorithms, by ensuring that all links can be safely dereferenced and that every list (even one that contains no data elements) always has a "first" and "last" node.\
\
Q.50 Applications of linked lists: \
Linked lists concepts are useful to model many different abstract data types such as queues stacks and trees. If we restrict the process of insertions to one end of the list and deletions to the other mode of a queue that is we can insert an item at the rear end and remove an item at the front end obeying the discipline first in first out. If we restrict the insertions and deletions to occur only at one end of list the beginning then the model is called stacks. Stacks are all inherently one-dimensional. A tree represents a two dimension linked list. Trees are frequently encounters in every day life one example are organization chart and the other is sports tournament chart.\
\
? Example program of Two Dimensional Linked List\
\
Q.51Declare constant member of a class\
\
\
Class MyClass \
\{\'a0 \'a0 \'a0 \'a0 \
	private :\
		const int m_nMaxWheels;\uc0\u8232 \'a0 \'a0 \'a0 \'a0 \
	public :\
		MyClass(int maxWheels) : m_nMaxWheels(maxWheels) \{\}\
\};\
\
MyClass myClass(4);\
\
Q.52 What is an abstract class, and when should it be used?\
Abstract classes are classes that contain one or more abstract methods. An abstract method is a method that is declared, but contains no implementation. Abstract classes may not be instantiated, and require subclasses to provide implementations for the abstract methods. Let's look at an example of an abstract class, and an abstract method.\
Suppose we were modelling the behaviour of animals, by creating a class hierarchy that started with a base class called Animal. Animals are capable of doing different things like flying, digging and walking, but there are some common operations as well like eating and sleeping. Some common operations are performed by all animals, but in a different way as well. When an operation is performed in a different way, it is a good candidate for an abstract method (forcing subclasses to provide a custom implementation). Let's look at a very primitive Animal base class, which defines an abstract method for making a sound (such as a dog barking, a cow mooing, or a pig oinking).\'a0\
\
Q.53.A Inlining Virtual Member Functions\
Generally, compilers can't inline a virtual function call if the it's resolved dynamically. Therefore, declaring a virtual member function inline might seem pointless. However, not every call of a virtual function is resolved dynamically; in some cases, the compiler can resolve the call statically, as if the function weren't virtual. In situations like these, the compiler can also inline the call. For example: \
 \
  class Base\
  \{\
  public:\
    inline virtual int f() \{ return 0; \}\
  \};\
\
  int main()\
  \{\
    Base b;\
    b.f(); // resolved statically; call can be inlined\
  \}\
The invocation of f() is resolved statically because b is not a pointer or a reference. The compiler can also expand the call inline, thereby optimising the code even further. \
Inline functions expands at compile time and virtual functions works at run time, so even if a virtual function declared inline, then compiler may expand it but actual call to that function is not confirm until it goes to linker i.e. at runtime.\
\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth17720\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Q.53.B Are there ant special rules about inlining?\
Yes, there are a few rules about inlining \'96 \
a.) Any source files that used the inline function must contain the function\'92s definition. \
b.) An inline function must be defined everywhere. The easier way to deal with this to define the function once in the class header file and include the definition as required. The harder way is to redefine the function everywhere and learn the one-definition rule. \
c.) Main() can not be inline.\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
Q.54 Pointer Arithmetic\
You can perform a limited number of arithmetic operations on pointers. These operations are: \
Increment and decrement \
Addition and substraction \
Comparison \
Assignment \
The increment (++) operator increases the value of a pointer by the size of the data object the pointer refers to. For example, if the pointer refers to the second element in an array, the ++ makes the pointer refer to the third element in the array. \
The decrement (--) operator decreases the value of a pointer by the size of the data object the pointer refers to. For example, if the pointer refers to the second element in an array, the -- makes the pointer refer to the first element in the array. \
You can add an integer to a pointer but you cannot add a pointer to a pointer. \
If the pointer p points to the first element in an array, the following expression causes the pointer to point to the third element in the same array: \
p = p + 2;\
If you have two pointers that point to the same array, you can subtract one pointer from the other. This operation yields the number of elements in the array that separate the two addresses that the pointers refer to. \
You can compare two pointers with the following operators: ==, !=, <, >, <=, and\'a0>=. \
Pointer comparisons are defined only when the pointers point to elements of the same array. Pointer comparisons using the == and != operators can be performed even when the pointers point to elements of different arrays. \
You can assign to a pointer the address of a data object, the value of another compatible pointer or the NULL pointer. \
\
Q.55 The previous answer gives the Binary output backwards.\'a0\'a0Here is a function for converting to Binary properly: \uc0\u8232 void convertToBinary() \u8232 \
\{ \uc0\u8232 \'a0\'a0\'a0\
	int num; \uc0\u8232 \'a0\'a0\'a0\
	int binary = 0; \uc0\u8232 \'a0\'a0\'a0\
	int place = 0; \uc0\u8232 \'a0\'a0\'a0\
	printf("Converting to Binary\\n"); \uc0\u8232 \'a0\'a0\
	printf("Enter an integer: "); \uc0\u8232 \'a0\'a0\'a0\
	scanf("%d", &num); \uc0\u8232 \'a0\'a0\'a0\
	while (num != 0) \uc0\u8232 \'a0\'a0\'a0\
	\{ \uc0\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\
		binary = binary + (num%2 * pow(10, place++)); \
\'a0\'a0\'a0\'a0\'a0\'a0		num = num /2; \uc0\u8232 \'a0\'a0\'a0\
	\} \uc0\u8232 \'a0\'a0\'a0\
	printf("The equivalent binary is %d\\n", binary); \uc0\u8232 \
\}\
\
Q.56 Multiple Inheritance \
\
Deriving directly from more than one class is usually called multiple inheritance. Since it's widely believed that this concept complicates the design and debuggers can have a hard time with it, multiple inheritance can be a controversial topic. However, multiple inheritance is an important feature in C++ and C++ programmers think of it as a very good structuring tool.\
\
Pitfalls\
\
The most difficult to avoid complication that arises when using multiple inheritance is that sometimes the programmers interested in using this technique to extend the existing code are forced to learn some of the implementation's details. The second trivial problem that might appear when using this technique is the creation of ambiguities:\
\
class A \{ virtual void f(); \};\
class B \{ virtual void f(); \};\
class C : public A ,public B \{ void f(); \};\
\
This issue can be solved by using explicit qualification. We explicitly say to the compiler where to get the function that we need to call:\
C* pc = new C;\
pc->f();\
pc->A::f(); //this calls f() from class A\
pc->B::f(); //this calls f() from class B\
\
Each base class can be uniquely identified by using the scope resolution operator :: .\
\
If the C class didn't have the method f() the problem couldn't have been solved with explicit qualification. Instead we would have used implicit conversion :\
\
A* pa = pc;\
pa->f();\
\
or we would have to make a cast in order to call the method from the parent class A.\
\
57. What is Use cases\
In software and systems engineering, a use case is a list of steps, typically defining interactions between a role and a system, to achieve a goal.\
\
58. Friend function\
In object-oriented programming, a friend function that is a "friend" of a given class is allowed access to private and protected data in that class that it would not normally be able to as if the data was public. [1] Normally, a function that is defined outside of a class cannot access such information.\
Friends should be used with caution. Too many functions or external classes declared as friends of a class with protected or private data may lessen the value of encapsulation of separate classes in object-oriented programming and may indicate a problem in the overall architecture design. Generally though, friend functions are a good thing for encapsulation, as you can keep data of a class private from all except those who you explicitly state need it, but this does mean your classes will become tightly coupled.\
\
This approach may be used when a function needs to access private data in objects from two different classes. This may be accomplished in two similar ways\
	\'95	a function of global or namespace scope may be declared as friend of both classes\
	\'95	a member function of one class may be declared as friend of another one.\
\
#include <iostream>\
using namespace std;\
 \
class Foo; // Forward declaration of class Foo in order for example to compile.\
class Bar \{\
  private:\
      int a;\
  public:\
      Bar(): a(0) \{\}\
      void show(Bar& x, Foo& y);\
      friend void ::show(Bar& x, Foo& y); // declaration of global friend\
\};\
 \
class Foo \{\
  private:\
      int b;\
  public: \
      Foo(): b(6) \{\}\
      friend void  ::show(Bar& x, Foo& y); // declaration of global friend\
      friend void Bar::show(Bar& x, Foo& y); // declaration of friend from other class \
\};\
 \
// Definition of a member function of Bar; this member is a friend of Foo\
void Bar::show(Bar& x, Foo& y) \{\
  cout << "Show via function member of Bar" << endl;\
  cout << "Bar::a = " << x.a << endl;\
  cout << "Foo::b = " << y.b << endl;\
\}\
 \
// Friend for Bar and Foo, definition of global function\
void show(Bar& x, Foo& y) \{\
  cout << "Show via global function" << endl;\
  cout << "Bar::a = " << x.a << endl;\
  cout << "Foo::b = " << y.b << endl;\
\}\
 \
int main() \{\
   Bar a;\
   Foo b;\
 \
   show(a,b);\
   a.show(a,b);\
\}\
\
59. Friend Class\
A friend class in C++, can access the "private" and "protected" members of the class in which it is declared as a friend. On declaration of friend class all member functions of the friend class become friends of the class in which the friend class was declared. Friend status is not inherited; every friendship has to be explicitly declared. Friend classes can help in improving Encapsulation if used wisely.\
Classes are declared as friends within the definition of the class who is giving access to others; this prevents a class from giving itself access to another's protected members, which enforces encapsulation. The friend class has the same level of access irrespective of whether the friend declaration appears in either the public, protected or private sections of the class definition. Friend status is granted by using the friend keyword:\
\
#include <iostream>\
 \
class B\
\{\
    // B declares A as a friend...\
    friend class A;\
 \
private:\
    void privatePrint()\
    \{\
        std::cout << "hello, world" << std::endl;\
    \}\
\};\
 \
class A\
\{\
public:\
    A()\
    \{\
        B b;\
        // ... and A now has access to B's private members\
        b.privatePrint();\
    \}\
\};\
 \
int main()\
\{\
    A a;\
    return 0;\
\}\
\
\
\
60. Inter Process Communication\
In numerous applications there is clearly a need for these processes to communicate with each exchanging data or control information. There are a few methods which can accomplish this task. We will consider:\
	\'95	Pipes\
	\'95	Signals\
	\'95	Message Queues\
	\'95	Semaphores\
	\'95	Shared Memory\
	\'95	Sockets\
	\'95	COM\
\
Boost.Interprocess simplifies the use of common interprocess communication and synchronization mechanisms and offers a wide range of them:\
	\'95	Shared memory.\
	\'95	Memory-mapped files.\
	\'95	Semaphores, mutexes, condition variables and upgradable mutex types to place them in shared memory and memory mapped files.\
	\'95	Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.\
	\'95	File locking.\
	\'95	Relative pointers.\
	\'95	Message queues.\
\
61.How can we access PRIVATE members outside class\
It's possible to access the private data of class directly in main and other's function...\
here is a small code...\
class GIFT\
\{\
    int i,j,k;\
\
public:\
    void Fun() \
    \{\
        cout<< i<<" "<< j<<" "<< k;\
    \}\
\
\};\
\
int main()\
\{\
     GIFT *obj=new GIFT(); // the value of i,j,k is 0\
     int *ptr=(int *)obj;\
     *ptr=10;\
     cout<<*ptr;      // you also print value of I\
     ptr++;\
     *ptr=15;\
     cout<<*ptr;      // you also print value of J\
     ptr++;\
     *ptr=20; \
     cout<<*ptr;      // you also print value of K\
     obj->Fun();\
\}\
The idea of\'a0Encapsulation\'a0is to bundle data and methods (that work on the data) together and restrict access of private data members outside the class.\'a0In C++, a friend function or friend class can also access private data members.\
Is it possible to access private members outside a class without friend?\uc0\u8232 Yes, it is possible using pointers. See the following program as an example.\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth4900\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf2 \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrs\brdrw20\brdrcf2 \clbrdrr\brdrs\brdrw20\brdrcf2 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 #include<iostream>\
using namespace std;\
\'a0\
class Test\
\{\
private:\
\'a0\'a0\'a0\'a0int data;\
public:\
\'a0\'a0\'a0\'a0Test() \{ data = 0; \}\
\'a0\'a0\'a0\'a0int getData() \{ return data; \}\
\};\
\'a0\
int main()\
\{\
\'a0\'a0\'a0\'a0Test t;\
\'a0\'a0\'a0\'a0int* ptr = (int*)&t;\
\'a0\'a0\'a0\'a0*ptr = 10;\
\'a0\'a0\'a0\'a0cout << t.getData();\
\'a0\'a0\'a0\'a0return 0;\
\}\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Output:\
10\
Note that the above way of accessing private data members is not at all a recommended way of accessing members and should never be used. Also, it doesn\'92t mean that the encapsulation doesn\'92t work in C++. The idea of making private members is to avoid accidental changes. The above change to data is not accidental. It\'92s an intentionally written code to fool the compiler.\
\
62. Testing Types\
Unit \'97> Integration \'97> System \'97> User Acceptance \'97> Regression\
[White & Black Box Testing, as well Automation Testing]\
\
63. How is global static different from global var,\
They are both in memory for the entire lifetime of the program. The variable that is declared static only has scope in the file in which it is declared where as the variable declared without static can be accessed from other files using an extern declaration.\
\
64. How is static used in class, how it is initialised,\
// inside the class\
class Thing \{\
    static string RE_ANY;\
    static string RE_ANY_RELUCTANT;\
\};\
\
// in the source file\
string Thing::RE_ANY = "([^\\\\n]*)";\
string Thing::RE_ANY_RELUCTANT = "([^\\\\n]*?)";\
\
how is const var initialised in a class,\
class C\
\{\
     const int x;\
\
public:\
      C() : x (5) \{ \}\
\};\
static const ?\
class X\
\{\
public:\
    static const int i = 1;\
\};\
\
65. Difference between C & C++\
1. C follows the procedural programming paradigm while C++ is a\'a0multi-paradigm\'a0language (procedural as well as object oriented)\
2.\'a0C is regarded as a low-level language(difficult interpretation & less user friendly) while C++ has features of both low-level(concentration on whats going on in the machine hardware) & high-level languages(concentration on the program itself) & hence is regarded as a middle-level language.\
3.\'a0C uses the top-down approach while C++ uses the bottom-up approach\'a0In case of C, the program is formulated step by step, each step is processed into detail while in C++, the base elements are first formulated which then are linked together to give rise to larger systems.\
4.\'a0C is function-driven while C++ is object-driven.\'a0\
5.\'a0We can use functions inside structures in C++ but not in C.\
\
\
66. DBMS vs RDBMS\
\
The software application that enables the users to store the data is known as a database. In database architecture, there are different implementations and theories in order to store physical data. The database which stores data in the tables that have relationships with other tables in the database is called RDBMS or Relational Database Management System. However, in DBMS or Database Management System, there are no relationships among tables\
\
67. Why Try Catch is not used everywhere in C++ library\
\
In c++, the cost depends on the implementation. In general, there are two ways to implement exceptions:\
The first is the "table" approach. The compiler builds a set of tables to look up, at the point where the exception is thrown, where to go. When the exception is thrown, it has to search through each table up the call stack until it finds something that will catch this exception. Since this is all runtime based, entering or exiting a try catch produces no penalty (good) but throwing an exception involves potentially many lookups, producing a much slower throw. I personally prefer the not-having-to-pay for try catch blocks, because exceptions should be a very rare circumstance. This also would make executables larger, if they have to store the tables.\
The seconds is the "code" approach. Each time the code enters a try catch block, conceptually, the location of the block is pushed onto a stack. This produces a cost during entering and exiting a try-catch block, however, when an exception is thrown, the runtime mechanism can quickly pop off the stack to find where to go. So, throwing exceptions is (much?) faster, but entering a block now has a cost. Putting a try catch block in a tight low level loop could produce significant overhead.\
You would have to check your specific compiler to see which one they use.\
\
\
68. What is re throw\
Rethrowing an expression from within an exception handler can be done by calling throw, by itself, with no exception. This causes current exception to be passed on to an outer try/catch sequence. An exception can only be rethrown from within a catch block. When an exception is rethrown, it is propagated outward to the next catch block.\
\
Consider following code:\
#include <iostream>\uc0\u8232 \
using namespace std;\uc0\u8232 \
void MyHandler()\uc0\u8232 \
\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	try\'a0\'a0\'a0\'a0\'a0 \
	\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
		throw \'93hello\'94;\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\}\uc0\u8232 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	catch (const char*)\'a0\'a0\'a0\'a0\'a0\'a0\
	\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
		cout <<\'94Caught exception inside MyHandler\\n\'94;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
		throw; //rethrow char* out of function\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\}\
\}\
int main()\
\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	cout<< \'93Main start\'94;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	try\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
		MyHandler();\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\}\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
	catch(const char*)\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
		cout <<\'94Caught exception inside Main\\n\'94;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	\}\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \
	cout << \'93Main end\'94;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
	return 0;\
\}\
\
O/p:\uc0\u8232 Main start\u8232 Caught exception inside MyHandler\u8232 Caught exception inside Main\u8232 Main end\u8232 Thus, exception rethrown by the catch block inside MyHandler() is caught inside main();\
\
69. Can we access non static data in static class ?\
1. Static functions can only access(write/read) static member variables\
2. Non-Static functions can access(write/read) static member variables\uc0\u8232 You cannot access a non static member inside a\'a0static\'a0method unless you explicitly make available the object instance inside the member function.(Pass object instance explicitly as argument or use a global instance which can be accessed inside the function)\u8232 For a non static member function an implicit\'a0this\'a0pointer is passed as the first argument to the function. The\'a0this\'a0pointer is dereferenced inside the member function to access the members.\'a0static members are not passed with the implicit\'a0this\'a0pointer so you cannot access non static members inside the function unless you explicitly get the object inside the member function.\u8232 \u8232 \u8232 \'a0have one question about static and non-static function and variable.\u8232 \
\
1) non-static function access static variable.\uc0\u8232 It's OK!\u8232 \
class Bar\
\{\
public:\
\
     static int i;\
\
     void nonStaticFunction() \{\
\
         Bar::i = 10;\
\
     \}\
\
\};\
\
int Bar::i=0;\uc0\u8232 \
\
2) non-static function access non-static variable\uc0\u8232 Definitely OK!\
3) static function access static variable&funciton\uc0\u8232 Definitely OK!\u8232 \
4) static function access non-static function\uc0\u8232 It's OK\u8232 \
\
class Bar\
\{\
public:\
     static void staticFunction( const Bar & bar)\
     \{\
         bar.memberFunction();\
\
     \}\
\
     void memberFunction() const\
     \{\
\
     \}\
\
\}\
\
5) static function access non-static variable\uc0\u8232 It's OK or not OK? I am puzzled about this!\u8232 How about this example\u8232 class Bar\
\{\
public:\
     static void staticFunction( Bar & bar)\
     \{\
         bar.memberFunction();\
\
     \}\
\
     void memberFunction()\
     \{\
\
         i = 0;\
     \}\
\
     int i;\
\
\};\
\uc0\u8232 When called, a static function isn't bound to an instance of the class. Class instances (objects) are going to be the entities that hold the "non-static" variables. Therefore, from the static function, you won't be able to access them without actually being passed or storing elsewhere a specific instance to operate on.\u8232 So yes, the code in your last example is valid, because you are passed in an instance. However, you could not do:\u8232 static void staticFunction()\
\{\
    // error, this function is static, and is therefore\
    // not bound to a specific instance when called\
    i = 5;\
\
\
\}\uc0\u8232 \
\
\
70. Can we return value from DLL ?\
Send a Pointer or Pointer-to-pointer, \
? please check google for more details\
\
\
71. Exceptions and Stack Unwinding in C++\
In the C++ exception mechanism, control moves from the throw statement to the first catch statement that can handle the thrown type. When the catch statement is reached, all of the automatic variables that are in scope between the throw and catch statements are destroyed in a process that is known as\'a0stack unwinding. In stack unwinding, execution proceeds as follows:\
\
\
1.Control reaches the\'a0try\'a0statement by normal sequential execution. The guarded section in the\'a0try\'a0block is executed.\
2.If no exception is thrown during execution of the guarded section, the\'a0catch\'a0clauses that follow the\'a0try\'a0block are not executed. Execution continues at the statement after the last\'a0catch\'a0clause that follows the associated\'a0try\'a0block.\
3.If an exception is thrown during execution of the guarded section or in any routine that the guarded section calls either directly or indirectly, an exception object is created from the object that is created by the\'a0throw\'a0operand. (This implies that a copy constructor may be involved.) At this point, the compiler looks for a\'a0catch\'a0clause in a higher execution context that can handle an exception of the type that is thrown, or for a\'a0catch handler that can handle any type of exception. The\'a0catch\'a0handlers are examined in order of their appearance after the\'a0try\'a0block. If no appropriate handler is found, the next dynamically enclosing\'a0try\'a0block is examined. This process continues until the outermost enclosing\'a0try block is examined.\
4.If a matching handler is still not found, or if an exception occurs during the unwinding process but before the handler gets control, the predefined run-time function\'a0terminate\'a0is called. If an exception occurs after the exception is thrown but before the unwind begins,\'a0terminate is called.\
5.If a matching\'a0catch\'a0handler is found, and it catches by value, its formal parameter is initialised by copying the exception object. If it catches by reference, the parameter is initialised to refer to the exception object. After the formal parameter is initialised, the process of unwinding the stack begins. This involves the destruction of all automatic objects that were fully constructed\'97but not yet destructed\'97between the beginning of the\'a0try\'a0block that is associated with the\'a0catch\'a0handler and the throw site of the exception. Destruction occurs in reverse order of construction. The\'a0catch\'a0handler is executed and the program resumes execution after the last handler\'97that is, at the first statement or construct that is not a\'a0catch\'a0handler. Control can only enter a\'a0catch\'a0handler through a thrown exception, never through a\'a0goto\'a0statement or a case\'a0label in a\'a0switch\'a0statement.\uc0\u8232 \u8232 The following example demonstrates how the stack is unwound when an exception is thrown. Execution on the thread jumps from the throw statement in\'a0C\'a0to the catch statement in\'a0main, and unwinds each function along the way. Notice the order in which the\'a0Dummy\'a0objects are created and then destroyed as they go out of scope. Also notice that no function completes except\'a0main, which contains the catch statement. Function\'a0A never returns from its call to\'a0B(), and\'a0B\'a0never returns from its call to\'a0C(). If you uncomment the definition of the\'a0Dummy\'a0pointer and the corresponding delete statement, and then run the program, notice that the pointer is never deleted. This shows what can happen when functions do not provide an exception guarantee. For more information, see How to: Design for Exceptions. If you comment out the catch statement, you can observe what happens when a program terminates because of an un handled exception.\u8232 \u8232 \u8232 \u8232 #include\'a0<string>\
#include\'a0<iostream>\
using\'a0namespace\'a0std;\
 \
class\'a0MyException\{\};\
class\'a0Dummy\
\{\
\'a0\'a0\'a0\'a0public:\
\'a0\'a0\'a0\'a0Dummy(string\'a0s)\'a0:\'a0MyName(s)\'a0\{\'a0PrintMsg("Created\'a0Dummy:");\'a0\}\
\'a0\'a0\'a0\'a0Dummy(const\'a0Dummy&\'a0other)\'a0:\'a0MyName(other.MyName)\{\'a0PrintMsg("Copy\'a0created\'a0Dummy:");\'a0\}\
\'a0\'a0\'a0\'a0~Dummy()\{\'a0PrintMsg("Destroyed\'a0Dummy:");\'a0\}\
\'a0\'a0\'a0\'a0void\'a0PrintMsg(string\'a0s)\'a0\{\'a0cout\'a0<<\'a0s\'a0\'a0<<\'a0MyName\'a0<<\'a0\'a0endl;\'a0\}\
\'a0\'a0\'a0\'a0string\'a0MyName;\'a0\
\'a0\'a0\'a0\'a0int\'a0level;\
\};\
 \
 \
void\'a0C(Dummy\'a0d,\'a0int\'a0i)\
\{\'a0\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Entering\'a0FunctionC"\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0d.MyName\'a0=\'a0"\'a0C";\
\'a0\'a0\'a0\'a0throw\'a0MyException();\'a0\'a0\'a0\
 \
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Exiting\'a0FunctionC"\'a0<<\'a0endl;\
\}\
 \
void\'a0B(Dummy\'a0d,\'a0int\'a0i)\
\{\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Entering\'a0FunctionB"\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0d.MyName\'a0=\'a0"B";\
\'a0\'a0\'a0\'a0C(d,\'a0i\'a0+\'a01);\'a0\'a0\'a0\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Exiting\'a0FunctionB"\'a0<<\'a0endl;\'a0\
\}\
 \
void\'a0A(Dummy\'a0d,\'a0int\'a0i)\
\{\'a0\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Entering\'a0FunctionA"\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0d.MyName\'a0=\'a0"\'a0A"\'a0;\
\'a0\'a0//\'a0\'a0Dummy*\'a0pd\'a0=\'a0new\'a0Dummy("new\'a0Dummy");\'a0//Not\'a0exception\'a0safe!!!\
\'a0\'a0\'a0\'a0B(d,\'a0i\'a0+\'a01);\
\'a0//\'a0\'a0\'a0delete\'a0pd;\'a0\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Exiting\'a0FunctionA"\'a0<<\'a0endl;\'a0\'a0\'a0\
\}\
 \
 \
int\'a0main()\
\{\
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Entering\'a0main"\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0try\
\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Dummy\'a0d("\'a0M");\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0A(d,1);\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0catch\'a0(MyException&\'a0e)\
\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Caught\'a0an\'a0exception\'a0of\'a0type:\'a0"\'a0<<\'a0typeid(e).name()\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0\}\
 \
\'a0\'a0\'a0\'a0cout\'a0<<\'a0"Exiting\'a0main."\'a0<<\'a0endl;\
\'a0\'a0\'a0\'a0char\'a0c;\
\'a0\'a0\'a0\'a0cin\'a0>>\'a0c;\
\}\
 \
/*\'a0Output:\
\'a0\'a0\'a0\'a0Entering\'a0main\
\'a0\'a0\'a0\'a0Created\'a0Dummy:\'a0M\
\'a0\'a0\'a0\'a0Copy\'a0created\'a0Dummy:\'a0M\
\'a0\'a0\'a0\'a0Entering\'a0FunctionA\
\'a0\'a0\'a0\'a0Copy\'a0created\'a0Dummy:\'a0A\
\'a0\'a0\'a0\'a0Entering\'a0FunctionB\
\'a0\'a0\'a0\'a0Copy\'a0created\'a0Dummy: B\
\'a0\'a0\'a0\'a0Entering\'a0FunctionC\
\'a0\'a0\'a0\'a0Destroyed\'a0Dummy:\'a0C\
\'a0\'a0\'a0\'a0Destroyed\'a0Dummy: B\
\'a0\'a0\'a0\'a0Destroyed\'a0Dummy:\'a0A\
\'a0\'a0\'a0\'a0Destroyed\'a0Dummy:\'a0M\
\'a0\'a0\'a0\'a0Caught\'a0an\'a0exception\'a0of\'a0type:\'a0class\'a0MyException\
\'a0\'a0\'a0\'a0Exiting\'a0main.\
 \
*/\uc0\u8232 \
\
72. What is Volatile\
A type qualifier that you can use to declare that an object can be modified in the program by the hardware.\
\
73. One Defination Rule\uc0\u8232 \
\
- In any translation unit, a template, type, function, or object can have no more than one definition. Some of these can have any number of declarations. A definition provides an instance.\
- In the entire program, an object or non-inline function cannot have more than one definition; if an object or function is used, it must have exactly one definition. You can declare an object or function that is never used, in which case you don't have to provide a definition. In no event can there be more than one definition.\
Some things, like types, templates, and extern inline functions, can be defined in more than one translation unit. For a given entity, each definition must be the same. Non-extern objects and functions in different translation units are different entities, even if their names and types are the same.\
\
In general, a translation unit shall contain no more than one definition of any class type. In this example, two definitions of the class type C occur in the same translation unit. This typically occurs if a header file is included twice by the same source file without appropriate header guards.\
class C \{\}; // first definition of C\
class C \{\}; // error, second definition of C\
In the following, forming a pointer to S or defining a function taking a reference to S are examples of legal constructs, because they do not require the type of S to be complete. Therefore, a definition is not required.[2]\
Defining an object of type S, a function taking an argument of type S, or using S in a sizeof expression are examples of contexts where S must be complete, and therefore require a definition.[2]\
struct S;     // declaration of S\
S * p;        // ok, no definition required\
void f(S&);   // ok, no definition required\
void f(S*);   // ok, no definition required\
S f();        // ok, no definition required  \
\
S s;          // error, definition required\
sizeof(S);    // error, definition required\
\
What is use of one definition rule ? \
\
74. RAII -\
In RAII, holding a resource is tied to object lifetime: resource allocation (acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction, by the destructor. If objects are destructed properly, resource leaks do not occur.\
This is a programming idiom which briefly means that you\
encapsulate a resource into a class (whose constructor usually - but not necessarily** - acquires the resource, and its destructor always releases it)\
use the resource via a local instance of the class* the resource is automatically freed when the object gets out of scope\
\
\
75. Class Variant\
?\
\
\
76. How to check memory allocation in constructor\
=> Exit(1) can be called to skip the destructor call in case of allocation failed in constructor. As well check the allocation in destructor before deleting. Initials using Init special function with try catch functionality to catch std:bad_alloc in case of allocation failure.\
\
=> \
myClass mc;\
if (!mc.initialized) \
\{\
    printf("Memory allocation failed in mc's constructor\\n");\
    exit(1);\
\}\
\
=>You should use new, not malloc. new throws std::bad_alloc when you are out of memory. An exception should be propagated from the constructor if you fail to allocate (or for any other reason have a problem with initialisation), as this is the only way you prevent the destructor from being called. If the constructor successfully completes, the destructor\'a0must\'a0be called (unless, of course, it was heap allocated and never freed).\
\
=>Overloading Operator new\
\
=> Example\
\
#include <iostream>\
class my_class \
\{\
private:\
  char * data;\
\
public:\
  my_class () \
  \{    \
    data = NULL;\
  \}\
\
  ~my_class () \
  \{\
    delete [] data;\
  \}\
\
  void init () \
  \{\
    data = new char [10000000000];\
  \}\
\
  void write (int x) \
  \{\
    data[x] = 1;\
  \}\
\};\
\
int main() \
\{\
  my_class my_instance;\
  try\
  \{\
    my_instance.init();\
  \}\
  catch (std::bad_alloc&) \
  \{\
    std::cout << "Memory overflow.\\n";\
    return 1;\
  \}\
\
  my_instance.write(10);\
  std::cout << "OK.\\n";\
  return 0;\
\}\
\
\
77. ActiveX Controls & Differences\
\
OLE\uc0\u8232 Is Windows 3.0's most exciting technology: the abilty to Embed and Link Objects between applications. It's first incarnation was based on DDE dialogs.\u8232 \u8232 COM\u8232 When OLE expanded, it was obvious that DDE was not firm grounds, so Microsoft decided to create a new foundation. A binary compatible, language independent, extremely lightweight (practically no runtime) protocol. That is the Component Object Model. It defines binary interfaces and allows programmes to commit to them (implement) and use those functional contracts.\u8232 \u8232 OCX\u8232 One of the most natural uses of COM was the replacement of old Visual Basic controls (VBX) for 32 bit more usable Ole Custom Controls (OCXs). There was a set of interfaces that allowed you to expose your object to be used on fellow programmer's toolbox.\u8232 \u8232 ActiveX\u8232 Enter the Internet and Internet Explorer. Microsoft wanted to make the Web Browser experience richer and so you could embed an OCX as part of a page content. Problem was, the amount of required interfaces was too large and downloading such entities on demand required time. So the standard was trimmed down to the necessary interfaces and renamed ActiveX. An ActiveX control is simply any COM object.\u8232 \u8232 And all this is history, I mean, the new grounds for Microsoft technology is now .NET and not COM. Problem is, there isn't a replacement for OLE (embedding, drag and drop, etc) -at least that I know of- based upon .NET.\
 \
78] Why should we use BOOST on top of STL\
BOOST can run with any compiler whereas STL can\'92t\
\
BOOST STL Comparison\
-It\'92s been ten years since they started to form a standard, and two years since the approval. A lot changed in that time, and the compiler vendors couldn\'92t really risk implementing new features if those features would be scrapped later on. The resulting picture really has not been pretty.\
-Boost, however, has been moving along well. The developers have done a superior job of making sure their code works with different compilers. Boost is mature, well-tested, and works well. The development process has moved forward without being encumbered by a standards committee. It continues to evolve.\
And what about those parts of it that made it into the Standard Library? I mentioned the Regular Expression library is very similar and was heavily influenced by Boost. But considering that implementations of the Standard Library still lack a lot of the features in the specification, does it even matter? Remember, the C++ standard itself isn\'92t code, and there is no reference implementation. The standard only says what a C++ compiler should do and what should be present in an implementation of the Standard Library. If you want to use the Standard Library, you have to use one produced by a third party\'97usually the one that comes with the compiler, such as the GCC version or the Microsoft version. And that\'92s what you\'92re really choosing between: GCC or Microsoft\'92s implementation of the Standard Library, or the Boost library upon which the Standard Library was modeled. And those two implementations of the Standard Library aren\'92t even complete, and one is called \'93experimental.\'94 Which one would you prefer to ship out to production?\
The Standards Committee took some eight years to fight over what should be in the standard, and the compiler vendors had to wait for all that to get ironed out before they could publish an implementation of the Standard Library. They did publish pieces, but it was clear they were early alpha versions at best. And they\'92re still not completely there yet. But meanwhile the actual C++ community was moving forward on its own, building better things such as Boost.\
We\'92re told there will be another standard in a few more years. We\'92ve heard that before. I imagine by then Boost will be even better yet.\
Difference between map of STL/BOOST/VC++\
\
\
79] Function pointers :\
Functions and function pointers with different calling convention are incompatible with each other.\
http://www.codeguru.com/cpp/cpp/cpp_mfc/callbacks/article.php/c10557\
\
// 2.1 define a function pointer and initialize to NULL\
int (*pt2Function)(float, char, char) = NULL;           			// C\
int (TMyClass::*pt2Member)(float, char, char) = NULL;       		// C++\
int (TMyClass::*pt2ConstMember)(float, char, char) const = NULL; 	// C++\
\
// C\
int DoIt  (float a, char b, char c)\{ printf("DoIt\\n");   return a+b+c; \}\
int DoMore(float a, char b, char c)const\{ printf("DoMore\\n"); return a-b+c; \}\
\
pt2Function = DoIt;      						// short form\
pt2Function = &DoMore;   					// correct assignment using address operator\
\
// C++\
class TMyClass\
\{\
public:\
   int DoIt(float a, char b, char c)\{ cout << "TMyClass::DoIt"<< endl; return a+b+c;\};\
   int DoMore(float a, char b, char c) const\{ cout << "TMyClass::DoMore" << endl; return a-b+c; \};\
\
   /* more of TMyClass */\
\};\
\
pt2ConstMember = &TMyClass::DoMore; // correct assignment using address operator\
pt2Member = &TMyClass::DoIt; // note: <pt2Member> may also legally point to &DoMore\
\
// 2.5 calling a function using a function pointer\
int result1 = pt2Function    (12, 'a', 'b');          	// C short way\
int result2 = (*pt2Function) (12, 'a', 'b');          	// C\
\
TMyClass instance1;\
int result3 = (instance1.*pt2Member)(12, 'a', 'b');   	// C++\
int result4 = (*this.*pt2Member)(12, 'a', 'b');       	// C++ if this-pointer can be used\
\
TMyClass* instance2 = new TMyClass;\
int result4 = (instance2->*pt2Member)(12, 'a', 'b');  	// C++, instance2 is a pointer\
delete instance2;\
\
//------------------------------------------------------------------------------------\
// 2.6 How to Pass a Function Pointer\
\
// <pt2Func> is a pointer to a function which returns an int and takes a float and two char\
void PassPtr(int (*pt2Func)(float, char, char))\
\{\
   int result = (*pt2Func)(12, 'a', 'b');     // call using function pointer\
   cout << result << endl;\
\}\
\
// execute example code - 'DoIt' is a suitable function like defined above in 2.1-4\
void Pass_A_Function_Pointer()\
\{\
   cout << endl << "Executing 'Pass_A_Function_Pointer'" << endl;\
   PassPtr(&DoIt);\
\}\
\
\
//------------------------------------------------------------------------------------\
// 2.8 How to Use Arrays of Function Pointers\
\
// type-definition: 'pt2Function' now can be used as type\
typedef int (*pt2Function)(float, char, char);\
\
// define arrays and ini each element to NULL, <funcArr1> and <funcArr2> are arrays\
// with 10 pointers to functions which return an int and take a float and two char\
\
// first way using the typedef\
pt2Function funcArr1[10] = \{NULL\};\
\
// 2nd way directly defining the array\
int (*funcArr2[10])(float, char, char) = \{NULL\};\
\
\
// assign the function's address - 'DoIt' and 'DoMore' are suitable functions\
// like defined above in 2.1-4\
funcArr1[0] = funcArr2[1] = &DoIt;\
funcArr1[1] = funcArr2[0] = &DoMore;\
\
/* more assignments */\
\
// calling a function using an index to address the function pointer\
printf("%d\\n", funcArr1[1](12, 'a', 'b'));         //  short form\
printf("%d\\n", (*funcArr1[0])(12, 'a', 'b'));      // "correct" way of calling\
printf("%d\\n", (*funcArr2[1])(56, 'a', 'b'));\
printf("%d\\n", (*funcArr2[0])(34, 'a', 'b'));\
\
80. Why Should You Use Callback Functions?\
Because they uncouple the caller from the callee. The caller doesn't care who the callee is; all it knows is that there is a callee with a certain prototype and probably some restriction (for instance, the returned value can be int, but certain values have certain meanings).\
If you are wondering how is that useful in practice, imagine that you want to write a library that provides implementation for sorting algorithms (yes, that is pretty classic), such as bubble sort, shell short, shake sort, quick sort, and others. The catch is that you don't want to embed the sorting logic (which of two elements goes first in an array) into your functions, making your library more general to use. You want the client to be responsible to that kind of logic. Or, you want it to be used for various data types (ints, floats, strings, and so on). So, how do you do it? You use function pointers and make callbacks.\
A callback can be used for notifications. For instance, you need to set a timer in your application. Each time the timer expires, your application must be notified. But, the implementer of the time'rs mechanism doesn't know anything about your application. It only wants a pointer to a function with a given prototype, and in using that pointer it makes a callback, notifying your application about the event that has occurred. Indeed, the SetTimer() WinAPI uses a callback function to notify that the timer has expired (and, in case there is no callback function provided, it posts a message to the application's queue).\
Another example from WinAPI functions that use callback mechanism is EnumWindow(), which enumerates all the top-level windows on the screen. EnumWindow() iterates over the top-level windows, calling an application-provided function for each window, passing the handler of the window. If the callee returns a value, the iteration continues; otherwise, it stops. EnumWindows() just doesn't care where the callee is and what it does with the handler it passes over. It is only interested in the return value, because based on that it continues its execution or not.\
However, callback functions are inherited from C. Thus, in C++, they should be only used for interfacing C code and existing callback interfaces. Except for these situations, you should use virtual methods or functions, not callback functions.\
\
\
81.INTERFACE [Need to explore again]\
	\'95	In C++, an interface is written as an abstract base class that has only pure virtual functions.\
	\'95	Interfaces may inherit from other interfaces. Inheritance works just like single inheritance in C++. \
	\'95	Multiple inheritance is not allowed with interfaces. \
	\'95	We don't have any interface keyword in C++.\
	\'95	C doesn't have interfaces like Java does. In fact, it doesn't even have classes. The closes thing it has to interfaces might be a pointer to a function, which could point to one of several different functions without the caller having to know which one exactly. \
\
Answer \
C does not have interfaces or classes. However it's quite easy to simulate interfaces and classes in C. Before I get into doing that, let me explain what interfaces are and how it's done in C++, which supports multiple inheritance which is much more powerful then interface inheritance. \uc0\u8232 \u8232 Interface inheritance is basically the same thing as multiple inheritance. In interface inheritance, the interfaces are classes that cannot have method implementations and variables. They may only have function prototypes. You are only allowed to inherit from one full blown class as a child in the interface inheritance model. \u8232 \u8232 However, in multiple inheritance (which C++ supports), you're allowed to inherit from as many full classes as you want. This allows you to make those full blown classes as slim as a bunch of pure virtual functions (interface) or as full classes with method implementations and variables. For example, to implement something similar to a comparable interface in C++: \u8232 \u8232 82. Explain storage qualifiers in C++.\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth17720\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 i.) Const - This variable means that if the memory is initialised once, it should not be altered by a program. \
ii.) Volatile - This variable means that the value in the memory location can be altered even though nothing in the program code modifies the contents. \
iii.) Mutable - This variable means that a particular member of a structure or class can be altered even if a particular structure variable, class, or class member function is constant.\
\
83. Explain dangling pointer.\
When the address of an object is used after its lifetime is over, dangling pointer comes into existence. Some examples of such situations are: Returning the addresses of the automatic variables from a function or using the address of the memory block after it is freed.\
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth17720\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap2\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 84.A Do you think the following code is fine? If not, what is the problem?\'a0\
T *p = 0; \
delete p;\
No, the code has a problem. The program will crash in an attempt to delete a null pointer.\'a0\'a0\nestcell \lastrow\nestrow
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
84.B Can we delete a pointer twice ?\
You get undefined behaviour if you try to delete an object through a pointer more that once.\
This means that pretty much anything can happen from 'appearing to work' to 'crashing' or something completely random.\
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth17720\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap2\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 85. What are the different types of STL containers?\
Following are the 3 types of STL containers:\
1. Adaptive containers - for e.g. queue, stack \
2. Associative containers - for e.g. set, map \
3. Sequence containers - for e.g. vector, deque\
\
map : A std::map is an associative container, that allows you to have a unique key associated with your type value. i.e. Maps have <key, values> where the keys are unique.\
\
multi map : A std::multimap is equal to a std::map, but your keys are not unique anymore. Therefore you can find a range of items instead of just find one unique item. i.e. Multimap have <key value, values> where more than one value can map to a key value.\
\
set : A set is an STL container that stores values and permits easy lookup. For example, you might have a set of strings: std::set<std::string> S; You can add a new element by writing \
                        S.insert("foo");.\uc0\u8232 A set may not contain more than one element with the same key, so insert won't add anything if S already contains the string "foo"; instead it just looks up the old element. The return value includes a status code indicating whether or not the new element got inserted. Set contains ordered elements.\
\
multiset : Multisets are containers that store elements following a specific order, and where multiple elements can have equivalent values.\
The value of the elements in a set/multiset cannot  be modified once in the container (
\b the elements are always const
\b0 ), but they can be inserted or removed from the container.\
\
86. Internal implementation of MAP : The ordered containers, including std::map are implemented as balanced binary trees (usually RB trees, but any other balanced tree would fit the requirements). A red\'96black tree is a data structure which is a type of self-balancing binary search tree. In computer science, a self-balancing (or height-balanced) binary search tree is any node-based binary search tree that automatically keeps its height (maximal number of levels below the root) small in the face of arbitrary item insertions and deletions.\
\
87.A Internal implementation of VECTOR\
std::vector, as the name itself suggests, is implemented with a normal dynamically-allocated array, that is reallocated when its capacity is exhausted (usually doubling its size or something like that).\
\
Vector is implemented as a dynamically allocated array. The memory for this array is allocated in the constructor. As more elements are inserted the array is dynamically increased in size. A constructor without parameter creates an array with a default size. Another constructor with integer parameter creates an array of the specified size. The destructor deletes the memory allocated for the array. [Check Program.txt for code]\
\
87.B How to find item in vector\
if your vector is not ordered, use the approach\
std::find(vector.begin(), vector.end(), item)!=vector.end()\
\
If your vector is ordered, use binary_search method\
if(binary_search(vector.begin(), vector.end(), item))\
\
88.  Internal implementation of LIST\
std::list instead is (usually1) implemented with a doubly-linked list.\
\nestcell \lastrow\nestrow
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 ? Internal of Multimap / Set / MultiSet\
\
89. Difference between vector and set\
-A set is ordered. It is guaranteed to remain in a specific ordering, according to a functor that you provide. No matter what elements you add or remove (unless you add a duplicate, which is not allowed in a set), it will always be ordered.\
-A vector has exactly and only the ordering you explicitly give it. Items in a vector are where you put them. If you put them in out of order, then they're out of order; you now need to sort the container to put them back in order.\
-Admittedly, set has relatively limited use. With proper discipline, one could insert items into a vector and keep it ordered. However, if you are constantly inserting and removing items from the container, vector will run into many issues. It will be doing a lot of copying/moving of elements and so forth, since it is effectively just an array.\
-The time it takes to insert an item into a vector is proportional to the number of items already in the vector. The time it takes to insert an item into a set is proportional to the log of the number of items. If the number of items is large, that's a huge difference. Log(100,000) is 5; that's a major speed improvement. The same goes for removal.\
-However, if you do all of your insertions at once, at initialization time, then there's no problem. You can insert everything into the vector, sort it (paying that price once), and then use standard algorithms for sorted vectors to find elements and iterate over the sorted list. And while iteration over the elements of a set isn't exactly slow, iterating over a vector is faster.\
-So there are cases where a sorted vector beats a set. That being said, you really shouldn't bother with the expense of this kind of optimization unless you know that it is necessary. So use a set unless you have experience with the kind of system you're writing (and thus know that you need that performance) or have profiling data in hand that tells you that you need a vector and not a set.\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
90.A What is conversion constructor\
In C++, if a class has a constructor which can be called with a single argument, then this constructor becomes conversion constructor because such a constructor allows automatic conversion to the class being constructed.\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth11220\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 #include<iostream>\
\'a0\
using namespace std;\
class Test \
\{\
\'a0private:\
\'a0\'a0\'a0int x;\
\'a0public:\
\'a0\'a0\'a0Test(int i) \{x = i;\}\
\'a0\'a0\'a0void show() \{ cout<<" x = "<<x<<endl; \}\
\};\
\'a0\
int main()\
\{\
\'a0Test t(20);\
\'a0t.show();\
\'a0t = 30; // conversion constructor is called here.\
\'a0t.show();\
\'a0getchar();\
\'a0return 0;\
\}\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The above program prints:\
x = 20\
x = 30\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b \cf0 90.B Class with default members
\b0 \
#include <iostream> \
class Explicit \{\
    friend class Implicit;\
    string msg;\
public:\
    Explicit() : msg("") \
    \{\
        std::cout << "Default constructor " << msg << '\\n';\
    \}\
 \
    Explicit(const string& value) : msg(value) \
    \{\
        std::cout << "Non-default constructor " << msg << '\\n';\
    \}\
 \
    Explicit(const Explicit& other) : msg(other.msg) \
    \{\
        std::cout << "Copy constructor " << msg << '\\n';\
    \}\
 \
     Explicit& operator=(const Explicit& other) \
    \{\
        std::cout << "Copy assignment operator " << msg << '\\n';\
        if (this != &other) \{\
            msg = other.msg;\
        \}\
        return *this;\
    \}\
 \
    ~Explicit() \
    \{\
        std::cout << "Destructor " << msg << '\\n';\
    \}\
\};\
 \
class MyClass \{\
    MyClass();                                			// Default ctor\
    MyClass(int a_param);                     		// Ctor\
    MyClass(const MyClass& other);            		// Copy ctor\
    MyClass(MyClass&& other);                 		// Move ctor\
    MyClass& operator=(const MyClass& other); 	// Copy assignment op\
    MyClass& operator=(MyClass&& other);      	// Move assignment op\
    ~MyClass();                               			// Dtor\
\};\
\
? Difference between usage of copy constructor and assignment operator & complete example of these constructor\
\
\

\b 91A. Move constructor
\b0 \
The move constructor is called whenever an object is initialized from xvalue of the same type, which includes\
	\uc0\u9642 	initialization, T a = std::move(b); or T a(std::move(b));, where b is of type T\
	\uc0\u9642 	function argument passing: f(std::move(a));, where a is of type T and f is void f(T t)\
	\uc0\u9642 	function return: return a; inside a function such as T f(), where a is of type T which has a move constructor.\
Move constructors typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, moving from a std::string or from a std::vector may result in the argument being left empty. However, this behaviour should not be relied upon.\
\
A move constructor looks like this:\
\
C::C(C&& other); //C++11 move constructor\
\
It doesn\'92t allocate new resources. Instead, it pilfers/steal other\'91s resources and then sets other to its default-constructed state.\
\
Let\'92s look at a concrete example. Suppose you\'92re designing a MemoryPage class that represents a memory buffer:\
class MemoryPage\uc0\u8232 \{\u8232 size_t size;\u8232 char * buf;\u8232 public:\u8232 explicit MemoryPage(int sz=512):\u8232 size(sz), buf(new char [size]) \{\}\u8232 ~MemoryPage( delete[] buf;\}\u8232 //typical C++03 copy ctor and assignment operator\u8232 MemoryPage(const MemoryPage&);\u8232 MemoryPage& operator=(const MemoryPage&);\u8232 \};\
\
A typical move constructor definition would look like this:\
//C++11\uc0\u8232 MemoryPage(MemoryPage&& other): size(0), buf(nullptr)\u8232 \{\u8232 \
// pilfer other\'92s resource\uc0\u8232 size=other.size;\u8232 buf=other.buf;\u8232 \
// reset other\uc0\u8232 other.size=0;\u8232 other.buf=nullptr;\u8232 \
\}\
The move constructor is much faster than a copy constructor because it doesn\'92t allocate memory nor does it copy memory buffers.\
\
\

\b 91B.Designing a Move Assignment Operator
\b0 \
A move assignment operator has the following signature:\
C& C::operator=(C&& other);//C++11 move assignment operator\
A move assignment operator is similar to a copy constructor except that before pilfering the source object, it releases any resources that its object may own. The move assignment operator performs four logical steps:\
	\'95	Release any resources that *this currently owns.\
	\'95	Pilfer other\'91s resource.\
	\'95	Set other to a default state.\
	\'95	Return *this.\
Here\'92s a definition of MemoryPage\'91s move assignment operator:\
//C++11\uc0\u8232 MemoryPage& MemoryPage::operator=(MemoryPage&& other)\u8232 \{\u8232 if (this!=&other)\u8232 \{\u8232 // release the current object\'92s resources\u8232 delete[] buf;\u8232 size=0;\u8232 // pilfer other\'92s resource\u8232 size=other.size;\u8232 buf=other.buf;\u8232 // reset other\u8232 other.size=0;\u8232 other.buf=nullptr;\u8232 \}\u8232 return *this;\u8232 \}\
\

\b 92. Size of class
\b0 \
Size of an empty class is not zero. It is 1 byte generally. It is nonzero to ensure that the two different objects will have different addresses. See the following example.\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth11220\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
#include <iostream>\
using namespace std;\
class Empty\
\{\};\
class Derived1 : public Empty\
\{\};\
class Derived2 : virtual public Empty\
\{\};\
class Derived3 : public Empty\
\{\'a0\'a0\'a0 \
\'a0\'a0\'a0\'a0char c;\
\};\
class Derived4 : virtual public Empty\
\{\
\'a0\'a0\'a0\'a0char c;\
\};\
class Dummy\
\{\
\'a0\'a0\'a0\'a0char c;\
\};\
\'a0\'a0\
int main()\
\{\
\'a0\'a0\'a0\'a0cout << "sizeof(Empty) " << sizeof(Empty) << endl;\
\'a0\'a0\'a0\'a0cout << "sizeof(Derived1) " << sizeof(Derived1) << endl;\
\'a0\'a0\'a0\'a0cout << "sizeof(Derived2) " << sizeof(Derived2) << endl;\
\'a0\'a0\'a0\'a0cout << "sizeof(Derived3) " << sizeof(Derived3) << endl;\
\'a0\'a0\'a0\'a0cout << "sizeof(Derived4) " << sizeof(Derived4) << endl;\'a0\'a0\'a0 \
\'a0\'a0\'a0\'a0cout << "sizeof(Dummy) " << sizeof(Dummy) << endl;\
\'a0\'a0\'a0\'a0return 0;\
\}\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Output :\
sizeof(Empty) 1\
sizeof(Derived1) 1\
sizeof(Derived2) 4\
sizeof(Derived3) 1\
sizeof(Derived4) 8\
sizeof(Dummy) 1\
\
Well in class Derived4 has 1 cha variable having 1 byte size and virtual pointer is in vtable has 4 byte which is virtual base class of empty and size so total size is 5 byte but system point of memory mapping is generally padding or call round of size so that it shows 8 byte.\
Please use __attribute__ ((__packed__)) end of Derived4 you will get exact size\
\
 class Derived4 : virtual public Empty\{ \
        char c;\
\}__attribute__ ((__packed__));\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b \cf0 93. Size of class with a virtual function ?\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b0 \cf0 #include<iostream>\
using namespace std; \
class A\
\{\
\
\};\
class B\
\{\
int i; \
\}; \
\
class C\
\{\
void foo();\
\};\
class D\
\{\
virtual void foo();\
\};\
\
class E\
\{\
int i ; \
    virtual void foo();\
\};\
class F\
\{\
int i; \
    void foo();\
\};\
class G\
\{\
    void foo();\
    int i;\
    void foo1();\
\};\
\
class H\
\{\
    int i ;\
    virtual void foo();\
    virtual void foo1();\
\};\
\
\
int main()\
\{\
cout <<"sizeof(class A) : " << sizeof(A) << endl ;\
cout <<"sizeof(class B) adding the member int i : " << sizeof(B) << endl ;\
cout <<"sizeof(class C) adding the member void foo() : " << sizeof(C) << endl ;\
cout <<"sizeof(class D) after making foo virtual : " << sizeof(D) << endl ;\
cout <<"sizeof(class E) after adding foo virtual , int : " << sizeof(E) << endl ;\
cout <<"sizeof(class F) after adding foo  , int : " << sizeof(F) << endl ;\
cout <<"sizeof(class G) after adding foo  , int : " << sizeof(G) << endl ;\
G g;\
cout <<"sizeof(class G) after adding foo  , int : " << sizeof(g) << endl ;\
cout <<"sizeof(class H) after adding int 2 virtual " << sizeof(H) << endl ;\
return 0; \
\}\
\
Output :\
sizeof(class A) : 1\
sizeof(class B) adding the member int i : 4\
sizeof(class C) adding the member void foo() : 1\
sizeof(class D) after making foo virtual : 8\
sizeof(class E) after adding foo virtual , int : 16\
sizeof(class F) after adding foo  , int : 4\
sizeof(class G) after adding foo   , unsigned int : 4\
sizeof(class g) after adding foo  , unsigned int : 4\
sizeof(class H) after adding int 2 virtual 16\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b \cf0 94. Data Padding
\b0 \
#include <stdio.h>\'a0\
// Alignment requirements\
// (typical 32 bit machine)\
\
// char \'a0 \'a0 \'a0 \'a0 1 byte\
// short int \'a0 \'a02 bytes\
// int \'a0 \'a0 \'a0 \'a0 \'a04 bytes\
// double \'a0 \'a0 \'a0 8 bytes\
\'a0\
// structure A\
typedef struct structa_tag\
\{\
\'a0\'a0\'a0char \'a0 \'a0 \'a0 \'a0c;\
\'a0\'a0\'a0short int \'a0 s;\
\} structa_t;\
\'a0\
// structure B\
typedef struct structb_tag\
\{\
\'a0\'a0\'a0short int \'a0 s;\
\'a0\'a0\'a0char \'a0 \'a0 \'a0 \'a0c;\
\'a0\'a0\'a0int \'a0 \'a0 \'a0 \'a0 i;\
\} structb_t;\
\'a0\
// structure C\
typedef struct structc_tag\
\{\
\'a0\'a0\'a0char \'a0 \'a0 \'a0 \'a0c;\
\'a0\'a0\'a0double \'a0 \'a0 \'a0d;\
\'a0\'a0\'a0int \'a0\'a0\'a0\'a0\'a0\'a0\'a0 s;\
\} structc_t;\
\'a0\
// structure D\
typedef struct structd_tag\
\{\
\'a0\'a0\'a0double \'a0 \'a0 \'a0d;\
\'a0\'a0\'a0int \'a0\'a0\'a0\'a0\'a0\'a0\'a0 s;\
\'a0\'a0\'a0char \'a0 \'a0 \'a0 \'a0c;\
\} structd_t;\
\'a0\
int main()\
\{\
\'a0\'a0\'a0printf("sizeof(structa_t) = %d\\n", sizeof(structa_t));\
\'a0\'a0\'a0printf("sizeof(structb_t) = %d\\n", sizeof(structb_t));\
\'a0\'a0\'a0printf("sizeof(structc_t) = %d\\n", sizeof(structc_t));\
\'a0\'a0\'a0printf("sizeof(structd_t) = %d\\n", sizeof(structd_t));\
\'a0\
\'a0\'a0\'a0return 0;\
\}\
sizeof(structa_t) = 4\
sizeof(structb_t) = 8\
sizeof(structc_t) = 24\
sizeof(structd_t) = 16\
structure A\
The structa_t first element is char which is one byte aligned, followed by short int. short int is 2 byte aligned. If the the short int element is immediately allocated after the char element, it will start at an odd address boundary. The compiler will insert a padding byte after the char to ensure short int will have an address multiple of 2 (i.e. 2 byte aligned). The total size of structa_t will be sizeof(char)\'a0+ 1 (padding) + sizeof(short), 1 + 1 + 2 = 4 bytes.\
\
structure B\
The first member of structb_t is short int followed by char. Since char can be on any byte boundary no padding required in between short int and char, on total they occupy 3 bytes. The next member is int. If the int is allocated immediately, it will start at an odd byte boundary. We need 1 byte padding after the char member to make the address of next int member is 4 byte aligned. On total, the structb_t requires 2 + 1 + 1 (padding) + 4 = 8 bytes.\
\
structure C \'96 Every structure will also have alignment requirements\
Applying same analysis, structc_t needs sizeof(char) + 7 byte padding + sizeof(double) + sizeof(int) = 1 + 7 + 8 + 4 = 20 bytes. However, the sizeof(structc_t) will be 24 bytes. It is because, along with structure members, structure type variables will also have natural alignment. Let us understand it by an example. Say, we declared an array of structc_t as shown below\
structc_t structc_array[3];\
Assume, the base address of structc_array is 0x0000 for easy calculations. If the structc_t occupies 20 (0x14) bytes as we calculated, the second structc_t array element (indexed at 1) will be at 0x0000 + 0x0014 = 0x0014. It is the start address of index 1 element of array. The double member of this structc_t\'a0will be allocated on 0x0014 + 0x1 + 0x7 = 0x001C (decimal 28) which is not multiple of 8 and conflicting with the alignment requirements of double. As we mentioned on the top, the alignment requirement of double is 8 bytes.\
Inorder to avoid such misalignment, compiler will introduce alignment requirement to every structure. It will be as that of the largest member of the structure. In our case alignment of structa_t is 2, structb_t is 4 and structc_t is 8. If we need nested structures, the size of largest inner structure will be the alignment of immediate larger structure.\
In structc_t of the above program, there will be padding of 4 bytes after int member to make the structure size multiple of its alignment. Thus the sizeof (structc_t) is 24 bytes.\'a0It guarantees correct alignment even in arrays. You can cross check.\
\
structure D \'96\'a0How to Reduce Padding?\
By now, it may be clear that padding is unavoidable. There is a way to minimize padding. The programmer should declare the structure members in their increasing ? /decreasing order of size. An example is structd_t given in our code, whose size is 16 bytes in lieu of 24 bytes of structc_t.\
\
\

\b 95. Inheritace
\b0 \
\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clmgf \clvertalc \clshdrawnil \clwWidth8748\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2160
\clmrg \clvertalc \clshdrawnil \clwWidth8748\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clmrg \clvertalc \clshdrawnil \clwWidth8748\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6480
\clmrg \clvertalc \clshdrawnil \clwWidth8748\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 All inheritance\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2268\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2160
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6480
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Base access specifier\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Public\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Private\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Protected\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2268\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2160
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6480
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Public\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Public\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Private\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Protected\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2268\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2160
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6480
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Private\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Not Inherited\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Not Inherited\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Not Inherited\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2268\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2160
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6480
\clvertalc \clshdrawnil \clwWidth2160\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Protected\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Protected\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Private\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Protected\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \
Private inheritance\
Some of the exceptions to be noted in C++ inheritance are as follows.\
The constructor and destructor of a base class are not inherited \
The assignment operator is not inherited \
The  HYPERLINK "http://www.codersource.net/cpp_tutorial_friend.html" friend functions and friend classes of the base class are also not inherited. \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b \cf0 96. Difference between Copy Cpnstructor & Assignment Operator
\b0 \
Copy constructor is called when a new object is created from an existing object, as a copy of the existing object (see this G-Fact). And assignment operator is called when an already initialized object is assigned a new value from another existing object.\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth11220\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 t2 = t1;\'a0 // calls assignment operator, same as "t2.operator=(t1);"\
Test t3 = t1;\'a0 // calls copy constructor, same as "Test t3(t1);"\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\b\fs16 \cf0 97. Object Slicing
\b0 \
In C++, a derived class object can be assigned to a base class object, but the other way is not possible.\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth11220\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
class\cf0  Base \{ \cf5 int\cf0 \kerning1\expnd0\expndtw0  x, y; \};\
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \'a0\
class Derived : public Base \{ \cf5 \expnd0\expndtw0\kerning0
int\cf0 \kerning1\expnd0\expndtw0  z, w; \};\
\'a0\
int main() \
\{\
\'a0\'a0\'a0\'a0Derived d;\
\'a0\'a0\'a0\'a0Base b = d; // Object Slicing,\'a0 z and w of d are sliced off\
\}\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object.\
\
\
\pard\pardeftab720\partightenfactor0

\fs18 \cf0 \expnd0\expndtw0\kerning0
Unnamed Namespaces :\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Unnamed namespaces are allowed and even encouraged in \cb6 .cc\cb1  files, to avoid link time naming conflicts:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \cb6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\
{\listtext	\'95	}\expnd0\expndtw0\kerning0
namespace \{                           // This is in a .cc file.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
// The content of a namespace is not indented.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
//\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
// This function is guaranteed not to generate a colliding symbol\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
// with other symbols at link time, and is only visible to\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
// callers in this .cc file.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
bool UpdateInternals(Frobber* f, int newval) \{\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
  ...\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\}\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\}  // namespace\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \cb1 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Do not use unnamed namespaces in \cb6 .h\cb1  files.\
\pard\tx560\pardeftab720\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \expnd0\expndtw0\kerning0
Implicit Conversions\cf8 \
\
\pard\pardeftab720\partightenfactor0
\cf9 Do not define implicit conversions. Use the \cb6 explicit\cb1  keyword for conversion operators and single-argument constructors.\
\
Implicit conversions allow an object of one type (called the source type) to be used where a different type (called the destination type) is expected, such as when passing an \cb6 int\cb1  argument to a function that takes a \cb6 double\cb1  parameter.\
\
In addition to the implicit conversions defined by the language, users can define their own, by adding appropriate members to the class definition of the source or destination type. An implicit conversion in the source type is defined by a type conversion operator named after the destination type (e.g. \cb6 operator bool()\cb1 ). An implicit conversion in the destination type is defined by a converting constructor, which is a constructor that can take the source type as its only argument. Note that a multi-parameter constructor can still be a converting constructor, if all but the first parameter have default values.\
\
The \cb6 explicit\cb1  keyword can be applied to a constructor or (since C++11) a conversion operator, to ensure that it can only be used when the destination type is explicit at the point of use, e.g. with a cast. This applies not only to implicit conversions, but to C++11's list initialization syntax:\
\cb6 \
class Foo \{\
  explicit Foo(int x, double y);\
  ...\
\};\
\
void Func(Foo f);\
\pard\pardeftab720\partightenfactor0
\cf9 \cb10 Func(\{42, 3.14\});  // Error\
\pard\tx560\pardeftab720\partightenfactor0
\cf0 \cb1 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\partightenfactor0

\fs16 \cf7 \expnd0\expndtw0\kerning0
Delegating and Inheriting Constructors\cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0
\cf9 \expnd0\expndtw0\kerning0
Use delegating and inheriting constructors when they reduce code duplication.\
Delegating and inheriting constructors are two different features, both introduced in C++11, for reducing code duplication in constructors. Delegating constructors allow one of a class's constructors to forward work to one of the class's other constructors, using a special variant of the initialization list syntax. For example:\
\cb6 X::X(const string& name) : name_(name) \{\
  ...\
\}\
\
X::X() : X("") \{\}\
\cb1 \
Inheriting constructors allow a derived class to have its base class's constructors available directly, just as with any of the base class's other member functions, instead of having to redeclare them. This is especially useful if the base has multiple constructors. For example:\
\cb6 class Base \{\
 public:\
  Base();\
  Base(int n);\
  Base(const string& s);\
  ...\
\};\
\
class Derived : public Base \{\
 public:\
  using Base::Base;  // Base's constructors are redeclared here.\
\};\
\cb1 This is especially useful when \cb6 Derived\cb1 's constructors don't have to do anything more than calling \cb6 Base\cb1 's constructors.\cf0 \kerning1\expnd0\expndtw0 \
\pard\tx560\pardeftab720\partightenfactor0
\cf0 \
Use below URL for Google CPP Guide\
https://google.github.io/styleguide/cppguide.html\
\
Bog O complexity Analysis\
\pard\pardeftab720\partightenfactor0

\f1\fs28 \cf11 \expnd0\expndtw0\kerning0
In {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Computer_science"}}{\fldrslt \cf12 computer science}}, big O notation is used to {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Computational_complexity_theory"}}{\fldrslt \cf12 classify algorithms}} by how they respond to changes in input size, such as how the processing time of an algorithm changes as the problem size becomes extremely large\
\
\pard\pardeftab720\partightenfactor0

\b\fs30 \cf13 \cb14 Big O notation is the language we use for articulating how long an algorithm takes to run
\b0 . It's how we compare the efficiency of different approaches to a problem.
\f0\fs16 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx560\pardeftab720\partightenfactor0
\cf0 \
What is 1\'92s complement\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 ? WinDebug\
? interOp\
? .NET Concept\
? C++ Concept\
? Programs fro Copy Constructor & Assignment operator and same for move semantics\
\
If you feel comfortable answering these questions, then rest assured that your chances of impressing any interviewer are very high. Be prepared to know basic computer science concepts such as data structures, search and sort algorithms, basic database concepts, etc. The client's needs will determine what particular branch of computer science you have to be familiar with, but you should always be ready to implement the stack, the queue, and the linked list data structures with either C or C++ programming languages. And know how to write your own version of strcpy (string copy) in C programming language since very often they ask you to do that. \
\
\
1. Does a class that contains objects of another class gain special access to the member variables of those objects?\uc0\u8232 \
A) No, a class that aggregates other objects does not have special access to those object\'92s member data and functions.\uc0\u8232 \u8232 \
\
2. Does an object which is a member of a parent class have access to the parent\'92s variables or methods?\uc0\u8232 \
A) No, aggregated members don\'92t have any special access to the members of the class which they are aggregated. The only ability they have to access the instance that aggregates them is to have a copy of the owner class \'93this\'94 pointer passed to them at creation or at some point thereafter. If this is done, they have the same normal access to that object as they would to any other.\uc0\u8232 \u8232 \
\
3. What is aggregation?\uc0\u8232 \
A) Aggregation is declaring an object as a member of another class contained by that class, this is also referred to as has-a.\uc0\u8232 \u8232 \
\
4. What is delegation?\uc0\u8232 \
A) Delegation is using the members of an aggregated class to perform functions for the containing class.\uc0\u8232 \u8232 \
\
5. What happens to the public functions and members of a base class when inherited into a derived class using private inheritance?\uc0\u8232 \
A) All the functions and members are then treated as if they were declared to be private, regardless of their actual access level in the base.\uc0\u8232 \u8232 6. Is private inheritance \'93Interface Inheritance\'94 or \'93Implementation Inheritance\'94? Why?\u8232 \
A) Implementation Inheritance, reason for this is that the class is invisible and therefore that class can\'92t be accessed directly, only by the derived class.\uc0\u8232 \u8232 \
\
7. What\'92s one method of making private members and functions available to specific classes, without exposing them to all clients?\uc0\u8232 \
A) One way is to declare that certain class to be a friend. This extends the interface of your class to include the friend class.\uc0\u8232 \u8232 \
\
8. Is friendship inherited?\uc0\u8232 \
A) No, friendship is not inheritable.\uc0\u8232 \u8232 \
\
9. Is friendship commutative? That is, does making class A a friend of class B automatically make the opposite true?\uc0\u8232 \
A) No, not automatically, though you can make Class A a friend of class B and class B a friend of class A by explicitly writing it in each class it\'92s declaration.\uc0\u8232 \u8232 \
\
10. Does \'93friendship\'94 reduce encapsulation? Why or why not?\uc0\u8232 \
A) No, because the friend declaration makes the declared friend a part of the class interface and does not have to undermine encapsulation.\uc0\u8232 \u8232 \
11. Does \'93friendship\'94 reduce modality? Why or why not?\uc0\u8232 \
A) Yes, reason is that using friend implies a commitment to parallel maintenance of both classes, which could reduce modularity.\uc0\u8232 \u8232 \
\
12. Do you have to declare an entire class a friend? What other options are there?\uc0\u8232 \
A) No, you can declare any function, regardless of whether it is a member function of another class, to be a friend.\
\
13. VTABLE is static or dynamic?\
A) It\'92s static, as each class has its separate VATBLE.\
\
14. What is conversion constructor ?\
A) A constructor that can be called with a single argument is used for conversions from the type of the argument to the class type. Such a constructor is called a conversion constructor.\
\
14) What is problem with Shared Memory?\
\
5) WAP for  Factorial number, Prime number, Fibonacci number, Linked List\
\
\
COM Introduction \
[Ref - http://www.codeproject.com/KB/COM/COM_InterviewQuestions.aspx]\
\
What is IUnknown? What methods are provided by IUnknown? \
It is a generally good idea to have an answer for this question if you claim you know COM in your resume. Otherwise, you may consider your interview failed at this point. IUnknown is the base interface of COM. All other interfaces must derive directly or indirectly from IUnknown. There are three methods in that interface: AddRef, Release and QueryInterface. \
\
What are the purposes of AddRef, Release and QueryInterface functions? \
AddRef increments reference count of the object, Release decrements reference counter of the object and QueryInterface obtains a pointer to the requested interface. \
\
What should QueryInterface functions do if requested object was not found? \
Return E_NOINTERFACE and nullify its out parameter. \
\
How can would you create an instance of the object in COM?\
Well, it all depends on your project. Start your answer from CoCreateInstance or CoCreateInstanceEx, explain the difference between them. If interviewer is still not satisfied, youll have to explain the whole kitchen behind the scenes, including a difference between local server and inproc server, meaning and mechanism of class factory, etc. You may also mention other methods of object creation like CoGetInstanceFromFile, but discussion will likely turn to discussion of monikers then. \
\
What happens when client calls CoCreateInstance? \
Again, all depends on the level of detail and expertise of interviewer. Start with simple explanation of class object and class factory mechanism. Further details would depend on a specific situation. \
\
What the limitations of CoCreateInstance?\
Well, the major problems with CoCreateInstance is that it is only able to create one object and only on local system. To create a remote object or to get several objects, based on single CLSID, at the same time, one should use CoCreateInstanceEx. \
\
What is aggregation? How can we get an interface of the aggregated object? \
Aggregation is the reuse mechanism, in which the outer object exposes interfaces from the inner object as if they were implemented on the outer object itself. This is useful when the outer object would always delegate every call to one of its interfaces to the same interface in the inner object. Aggregation is actually a specialized case of containment/delegation, and is available as a convenience to avoid extra implementation overhead in the outer object in these cases. We can get a pointer to the inner interface, calling QueryInterface of the outer object with IID of the inner interface. \
\
C is aggregated by B, which in turn aggregated by A. Our client requested C. What will happen? \
QueryInterface to A will delegate request to B which, in turn, will delegate request for the interface to C. This pointer will be returned to the client. \
\
What is a moniker ? \
An object that implements the IMoniker interface. A moniker acts as a name that uniquely identifies a COM object. In the same way that a path identifies a file in the file system, a moniker identifies a COM object in the directory namespace. \
\
Whats the difference, if any, between OLE and COM? OLE is build on top of COM. \
The question is not strict, because OLE was built over COM for years, while COM as a technology was presented by Microsoft a few years ago. You may mention also that COM is a specification, while OLE is a particular implementation of this specification, which in todays world is not exactly true as well, because what people call COM today is likely implementation of COM spec by Microsoft. \
\
Whats the difference between COM and DCOM? \
Again, the question does not require strict answer. Any DCOM object is yet a COM object (DCOM extends COM) and any COM object may participate in DCOM transactions. DCOM introduced several improvements/optimizations for distributed environment, such as MULTI_QI (multiple QueryInterface()), security contexts etc. DCOM demonstrated importance of surrogate process (you cannot run in-proc server on a remote machine. You need a surrogate process to do that.) DCOM introduced a load balancing. \
\
What is a dual interface? \
Dual interface is one that supports both - IDispatch interface and vtbl-based interface. Therefore, it might be used in scripting environment like VBScript and yet to use power and speed of vtbl-based interface for non-scripting environment. Discussion then may easily transform into analyzing of dual interface problems - be prepared to this twist. \
\
Can you have two dual interfaces in one class? \
Yes. You may have two dual interfaces in one class, but only one of them may be default. The bottom line is that you cannot work with two dual interfaces at the same time due to nature of dual interface! To support two dual interfaces in VB you would write something like:\
 INCLUDEPICTURE "http://www.codeproject.com/images/minus.gif" \\* MERGEFORMATINET Collapse INCLUDEPICTURE "http://www.codeproject.com/images/copy_16.png" \\* MERGEFORMATINET  HYPERLINK "http://www.codeproject.com/KB/COM/COM_InterviewQuestions.aspx"  Copy Code\
    dim d1 as IDualInterface1\
    dim d2 as IDualInterface2\
    set d1 = new MyClassWithTwoDuals\
    set d2 = d1\
    \
In ATLs class you would have to use macro COM_INTERFACE_ENTRY2(IDispatch,\uc0\u8232 IDualInterface1), to distinguish between different dual interfaces. \
\
What is marshalling by value? \
Some objects can essentially be considered static: regardless of which methods are called, the state of the object does not change. Instead of accessing such an object remotely, it is possible to copy the static state of the object and create a new object with the same state information on the caller side. The caller wont be able to notice the difference, but calls will be more efficient because they do not involve network round trips. This is called marshaling by value. \
\
What is a multi-threaded apartment (MTA)? Single-threaded apartment (STA)? \
This is pretty difficult question to describe shortly. Anyway, apartments were introduced by Microsoft in NT 3.51 and late Windows 95 to isolate the so called single-threaded apartment. The reason to create an object in apartment is thread-safety. COM is responsible synchronize access to the object even if the object inside of the apartment is not thread-safe. Multithreaded apartments (MTA, or free threading apartment) were introduced in NT 4.0. Idea behind MTA is that COM is not responsible to synchronize object calls between threads. In MTA the developer is responsible for that. See Professional DCOM Programming of Dr. Grimes et al. or Essential COM of Don Box for the further discussion on this topic. \
\
Lets assume we have object B and aggregated object C (in-proc server), created by B. Can you access any interface of B from C? \
Whats the difference between aggregated and contained objects? \
Yes, you can. This is fundamental postulate of COM: If you can get there from here, you can get there from anywhere, i.e. QIing for IUnknown you may proceed and to get a pointer to any other interface, supported by the object. Aggregated object exposes its interface directly, without visible intervention of the object container. Contained object is created within the object container and its interfaces might be altered or filtered by the object container. \
\
\
What is ROT ? GIT ? Count pros and cons of both. \
By definition, running object table (ROT) is a globally accessible table on each computer that keeps track of all COM objects in the running state that can be identified by a moniker. Moniker providers register an object in the table, which increments the objects reference count. Before the object can be destroyed, its moniker must be released from the table. Global Interface Table (GIT) allows any apartment (either single- or multi-threaded) in a process to get access to an interface implemented on an object in any other apartment in the process. \
If you have an object with two interfaces, can you custom marshal one of them? No! The decision to use custom marshalling is an all-or-nothing decision; an object has to custom marshal all its interfaces or none of them. \
\
Is there a way to register in-proc server without regsvr32.exe? \
Yes. Call DllRegisterServer() from the client. Do not forget to call DLLUnregisterServer() from the same client. You may also use Registrar object for the same purpose or use direct manipulation of the windows registry. \
\
What is VARIANT? Why and where would you use it? \
VARIANT is a huge union containing automation type. This allows easy conversion of one automation type to another. The biggest disadvantage of VARIANT is size of the union. \
\
How can you guarantee that only remote server is ever created by a client? \
Create an object (call CoCreateObjectEx()) with CLSCTX_REMOTE_SERVER flag. \
\
What is __declspec(novtable)? Why would you need this?  \
HYPERLINK "http://msdn.microsoft.com/library/en-us/vccelng/htm/msmod_17.asp" __declspec(novtable) is a Microsofts compiler optimization. The main idea of this optimization is to strip the vtable initialization code from abstract class (for abstract class the vtable is empty, while it is initialized in contructor) \
\
What is an IDL?\
IDL stands for Interface Definition Language. IDL is the language to describe COM interfaces. \
\
What is In-proc? \
In-proc is in-process COM object, i.e. COM object that implemented as DLL and supposed to be hosted by a container. When you have to instantiate the in-proc object remotely, you may use DLLHost.exe application [Surrogate Process] that was design specially for this purpose. \
\
What is OLE? \
OLE is an object and embedding first implementation of COM spec available from MS before COM was officially named COM. \
Give examples of OLE usage. The most famous examples are probably drag and drop and structured storage implementations. \
\
What are 2 storage types for composite document? \
Storage and Stream. \
\
Is .doc document a compound document? Is it a structured storage? \
Compound document is a document that contains information about other documents hosted in this document. All office documents _may_ be compound documents, but may be not. Word documents from version 6.0 and up are stored as structured storage. \
\
\
C++ References\
\
C++ Programming Language, by Bjarne Stroustrup (Addison Wesley, 1997). $44.95. \
\
C++: The Core Language, by Gregory Satir, Doug Brown, and Steven Qualline (O'Reilly & Associates, 1995). $24.95. \
\
C++ FAQs, by Marshall P. Cline, Greg A. Lomow, and Mike Girou (Addison-Wesley, 1998). $39.95 \
\
EffectiveC++: 50 Specific Ways to Improve Your Programs and Designs (2nd edition), by Scott Meyers (Addison-Wesley, 1997). $37.95. \
\
More Effective C++: 35 New Ways to Improve Your Programs and Designs, by Scott Meyers (Addison-Wesley, 1995). $39.95 \
\
Newsgroups: \
\
comp.lang.c++ \
\
comp.lang.c++.moderated \
\
***************************************\
Constructors and Copy Constructor: Constructors are special type of member function in a class which has the same name as the class itself. Constructor with no parameter is called default constructor. Any number of constructors can be declared and overloaded. Copy Constructor is a typical overloaded constructor that can accept a single argument of reference to same class type. The significance of this specific constructor is pretty high in the OO design aspect. There are several FAQs on this topic some of which are described and explained below.\
\'a0\
FAQS:\
\'a0\
1.\'a0\'a0\'a0\'a0\'a0 Does a class provide default Copy Constructor?\
2.\'a0\'a0\'a0\'a0\'a0 What does default Copy Constructor do?\
3.\'a0\'a0\'a0\'a0\'a0 Can a program have a virtual constructor?\
4.\'a0\'a0\'a0\'a0\'a0 When does a programmer need to implement his own copy constructor?\
5.\'a0\'a0\'a0\'a0\'a0 Can a copy constructor accept an object of the same class, instead of reference of the object?\
6.\'a0\'a0\'a0\'a0\'a0 What is the return parameter of a constructor and why?\
7.\'a0\'a0\'a0\'a0\'a0 Are the \'93default constructor\'94 and \'93constructor with default parameter\'94 same?\
\'a0\
Resolutions:\'a0\
1.\'a0\'a0\'a0\'a0 Does a class provide default Copy Constructor?\
Yes! The default copy constructor is being provided automatically by the compiler if not implemented separately. In this, it puts the code for coping the data members and other variables that stay in stack. If something is being created by malloc or new in the heap, those are not being copied by the default copy constructor provide by the compiler.\
\'a02.\'a0\'a0\'a0\'a0 What does a default Copy Constructor do?\'a0\
A default copy constructor is being provided by the compiler, when an attempt to copy an existing object is made. In this case the control goes to the default copy constructor. It generates a new object, and makes the values of data members of the new object which are in the stack, same as the parent object. It doesn\'92t copy the variables that are created in the heap. Simply speaking, a compiler supplied default copy constructor doesn\'92t take care of the things in an object, that are being created using malloc/calloc or new.\'a0\
3.\'a0\'a0\'a0\'a0 Can a program have a virtual constructor?\'a0\
Generally we don\'92t need an overridable constructor. So constructor should not be declared as virtual. But in a class, we can make a static method, which will call the private/protected constructor and create an object. In that case the constructor is called as virtual constructor.\
\'a04.\'a0\'a0\'a0\'a0 When does a programmer need to implement his own copy constructor?\'a0\
Though compiler automatically provides the default copy constructor, sometime a programmer needs to implement his own copy constructor. We can take up a case here:\
In the default constructor some memory allocation has been done for few data members and hence those will be created in the heap. In the destructor corresponding de-allocation code is there. Now if an attempt to copy an object is made, it won\'92t call the default constructor but it will call the default copy constructor which will copy the data member variable from stack and copy the pointers but won\'92t allocate any new memory space for the new copied object. So same pointers will exist in both the parent and copied object. This will not only create a great ambiguity but runtime error will occur when attempts will be made to delete both the objects. First object will get deleted properly. When it will try to delete the other object, the common pointer won\'92t exist and runtime error will come. Even if user stops the application it will try to delete all the objects in the memory and runtime error will occur. In a single word, copy constructor is needed to be implemented independently, when the parent object has some allocated memory in heap for some of its data member and that gets deleted by destructor. Copy constructor should consist that much of code for memory allocation for the newly created object.\'a0\
Apart from this, programmer can implement his own copy constructor to copy any other things, which he wants specifically.\'a0\
5.\'a0\'a0\'a0Can a copy constructor accept an object of the same class as parameter, instead of reference of the object?\'a0\
No. It is specified in the definition of the copy constructor itself. It should generate an error if a programmer specifies a copy constructor with a first argument that is an object and not a reference.\
Logically thinking, if we can consider the same as copy constructor also, big confusion will come. If we pass an object as a function parameter, by value, it will get copied first and then be passed to the function. At the time of getting copied it should call the copy constructor. So in this case, if we consider the above described constructor as copy constructor, at the very beginning of the function call, it wil attempt to copy the object and hence again call the same function and hence will go towards an infinite loop. This will probably be ended up with an unexpected stack overflow.\
It will give compiler error if an object of the same class is being passed to a constructor, but it doesn\'92t give error if more than one different objects are being passed to the constructor . In this case it doesn\'92t treat it as copy constructor, but a normal overloaded constructor.\'a0\
6.\'a0\'a0\'a0\'a0 What is the return parameter of a constructor and why?\'a0\
Constructor in never being called directly. It is being called automatically by the compiler when an object in being created (or copied). Hence it can\'92t return any parameter. Logically thinking, if it would have been made to return a parameter, how do we put the code to create an object?\'a0\
7.\'a0\'a0\'a0\'a0 Are the \'93default constructor\'94 and \'93constructor with default parameter\'94 same?\'a0\
Default constructor is a constructor, which can be called with no argument. So a constructor with all the parameters as default argument can be called as default constructor. A constructor with one or more default parameters (but not all the parameters) can be called \'93constructor with default parameter\'94 but that won\'92t be the default constructor.\
If a constructor with no argument and a constructor with all default arguments are being implemented then object-creation will generate an ambiguity regarding which constructor is to be called.\
8. Give a real time example of Singleton\
A classic example of a true singleton is a logging service. Suppose we have an event-based logging service: Client objects request that text be logged by sending a message to the logging service. Other objects actually log the text somewhere (console, file, whatever) by listening to the logging service for these logging requests and handling them. First, notice that the logging service passes the classic test for being a singleton: \
The requesters need a well-known object to which to send requests to log. This means a global point of access. \
Since the logging service is a single event source to which multiple listeners can register, there only needs to be one instance. \
\
\'a0\
\'a0\
Destructor : Destructor function can be treated as the  inverse of constructor functions. They are called when objects are destroyed (de-allocated) or program exits from application. Designate a function as a class\'92s destructor by preceding the class name with a tilde (~). There are several FAQs that a programmer comes across, some of which are explained below:\
\'a0\
\'a0\
FAQs:\
\'a01.\'a0\'a0\'a0\'a0\'a0 When and in what condition a destructor is called?\
2.\'a0\'a0\'a0\'a0\'a0 When does a programmer need a virtual destructor?\
3.\'a0\'a0\'a0\'a0\'a0 Does a destructor have some function parameter or return parameter?\
\'a0Resolutions:\
\'a01.\'a0\'a0\'a0\'a0 When and in what condition a destructor is called?\
\'a0There is only one destructor exists for a class. There can be two condition when the destructor is called. When attempt is made to delete the object and when user closes the application. When the application is being closed, all the objects are being deleted first and destructor corresponding to all the objects are called.\
\'a02.\'a0\'a0\'a0\'a0 When does a programmer need a virtual destructor?\
A good design should provide scope to override the destructors of all the classes. Destructor is the function that controls Pure virtual function and Abstract class: Pure virtual functions are the functions that are not being implemented in the class where it is being defined. An abstract class is a class that contains one or more than one pure virtual functions.\
I\'92ll soon come up with the following topics like:\
\'a0\
1.\'a0\'a0\'a0\'a0\'a0 Multiple Inheritance\
2.\'a0\'a0\'a0\'a0\'a0 Vtable for Multiple inheritance.\
3.\'a0\'a0\'a0\'a0\'a0 Virtual base class\
4.\'a0\'a0\'a0\'a0\'a0 Static class methods and static class members.\
5.\'a0\'a0\'a0\'a0\'a0 Macros and inline functions\
#define INC_X(x) (++(x))\
inline void inc_x(int x) \{ ++x; \}\
inline void inc_x_ref(int &x) \{ ++x; \}\
\
int main()\
\{\
      int y = 2;\
      INC_X(y); //y is now 3\
      inc_x(y); //y is still 3\
      inc_x_ref(y); //y is now 4\
      return 0;\
\}\
The difference is that the INC_X line will be converted by the preprocessor (before the compiler ever sees it) to "++(y)". The preprocessor does direct text substitution. The inc_x line, on the other hand, will be preserved as a  HYPERLINK "http://www.gidforums.com/t-9164.html" \\t "_top" function call, and will be inlined by the compiler. But since inc_x doesn't return its variable, it is useless and its argument will not be incremented. The fix for this, of course, is to use a reference, which is what inc_x_ref does. I hope this useless and convoluted code sample helps you understand the difference.\
\
6.\'a0\'a0\'a0\'a0\'a0 Private/protected constructor\
7.\'a0\'a0\'a0\'a0\'a0 Singleton class\
8.\'a0\'a0\'a0\'a0\'a0 Data type and storage specifier.\
9.\'a0\'a0\'a0\'a0\'a0 Volatile type qualifier\
10.\'a0 Malloc and calloc\
Difference Between Malloc and Calloc \
There are two differences. First, is in the number of arguments. Malloc() takes a single argument (memory required in bytes), while calloc() needs two arguments (number of variables to allocate memory, size in bytes of a single variable). Secondly, malloc() does not initialize the memory allocated, while calloc() initializes the allocated memory to ZERO. \
Here are more opinions and answers from FAQ Farmers: \
The difference between malloc and calloc are: 1. malloc() allocates byte of memory, whereas calloc()allocates block of memory. \
Calloc(m, n) is essentially equivalent to p = malloc(m * n); memset(p, 0, m * n); The zero fill is all-bits-zero, and does not therefore guarantee useful null pointer values (see section 5 of this list) or floating-point zero values. Free is properly used to free the memory allocated by calloc. \
Malloc(s); returns a pointer for enough storage for an object of s bytes. Calloc(n,s); returns a pointer for enough contiguous storage for n objects, each of s bytes. The storage is all initialized to zeros. \
Simply, malloc takes a single argument and allocates bytes of memory as per the argument taken during its invocation. Where as calloc takes two aguments, they are the number of variables to be created and the capacity of each vaiable (i.e. the bytes per variable). \
I think calloc can allocate and initialize memory, if the asked memory is available contiguously where as malloc can allocate even if the memory is not available contiguously but available at different locations.\
\
To determine which synchronization class you should use, ask the following series of questions:\
Does the application have to wait for something to happen before it can access the resource (for example, data must be received from a communications port before it can be written to a file)?\
If yes, use CEvent.\
Can more than one thread within the same application access this resource at one time (for example, your application allows up to five windows with views on the same document)?\
If yes, use CSemaphore.\
Can more than one application use this resource (for example, the resource is in a DLL)?\
If yes, use CMutex.\
If no, use CCriticalSection.\
CSyncObject is never used directly. It is the base class for the other four synchronization classes.\
\
\
Socket Programming :\
// Initialize Winsock.\
  WSAStartup(MAKEWORD(2,2), &wsaData);\
socket: creates a socket of a given domain, type, protocol(buy a phone)\
I bind: assigns a name to the socket (get a telephone number)\
I listen: specifies the number of pending connections that\
can be queued for a server socket. (call waiting allowance)\
I accept: server accepts a connection request from a client\
(answer phone)\
I connect: client requests a connection request to a server\
(call)\
I send, sendto: write to connection (speak)\
I recv, recvfrom: read from connection (listen)\
I shutdown: end the call\
// Clean up and quit. At this point, the application could\
// handle data transfer on the socket, or other socket\
// functionality.\
WSACleanup();\
\
\
VC+\
\
* Message Map is handled by CCmdTarget class\
SDI/MDI\
CArchive\
Class Hierarchy\
\
1] What is the base class for MFC Framework ?\
-> CObject is the base class for Microsoft Foundation Classes. It's used to support Serialisation, Runtime Class Information and Object diagnostics\
\
2] How to handle command line arguments from simple MFC application ?\
-> Using GetCommandLineArgs() function you can get the arguments in MFC application at any time. In InitInstance()  function you can change the behaviour of the application using those values.\
\
3] Why not virtual functions to handle messages?\
-> In MFC we have lot of base classes those are having so many virtual functions. For each class one virtual table will be created. This will consume lot of memory and our application performance will go down. This is the only reason MFC is not using virtual function for message mapping.\
\
4] Difference between SendMessage & PostMessage ?\
-> There are a few subtle differences in the ways you can send messages in Windows, but the basic difference between PostMessage and SendMessage is that SendMessage sends a message to another window immediately by calling that window's procedure and waiting for it to return, whereas PostMessage queues the message in an MSG structure and returns immediately without waiting.\
\
5] What is message loop how mfc does it internally?\
-> In Window programming Message is the main communication.The messages are stored in message queue. The way you retrieve messages from the Message Queue is by creating a Message Loop. A Message Loop is a loop that checks for messages in the Message Queue. once a message is received, the Message Loop dispatches the message by calling a Message Handler, a function designed to help the Message Loop at processing the message.\
\
Message loop ends when WM_QUIT message is retrieved. In Mfc WinMain is the entry point. Since mfc uses event driven programming model The Incoming messages enter in the message queue window procedure process that messages and send to window, winmain create that window and enter into message loop, retrieve messages and dispatches them to window procedure. Messages wait in message queue until they are retrieved. In order to retrieve and dispatch the message winmain execute simple while loop that call GetMessage, TranslateMessage and DispatchMessage API Functions. GetMessage retrieve message from message queue, TranslateMessage convert keyboard message to WM_CHAR message  and DispatchMessage dispatch messages to Window procedure. Message loop end when it retrieved WM_QUIT message.\
\
&&\
\
Generally Windows programming is an event driven programming.  As and when something happens the some message will be posted into message loop.\
\
First of all, WinMain is the function which is being called in windows application.  This WinMain calls Initinstance of that application and then enters the message loop.\
\
Suppose take the case of SDI/MDI Application: In SDI application messages are first sent it MainFrame class, if there is no message handle in MainFrame then the same message will be directed to CView. In the same way if there is a handle for the message in View then the message \
will be handled in the view other wise it will be directed to CDocument.  If there is message handle for the message in Document then that handler function will be called otherwise the message will be sent to CDocTemplate Class.  Then the message will be posed to another view if another view exists otherwise the message will be sent to DefWindowProc.\
\'a0\
6] What is serialization ? which function is responsible for serializing data ?\
-> A serializable class usually has a Serialize member function, and it usually uses the DECLARE_SERIAL and IMPLEMENT_SERIAL macros, as described under class CObject.\
\
The overloaded extraction (>>) and insertion (<<) operators are convenient archive programming interfaces that support both primitive types and CObject-derived classes. Serialize() function has to be overridden to take advantage of serialisation support\
\
7] What is the difference between GetMessage and PeekMessage ?\
-> The major difference between the two is that GetMessage() doesn't return until it finds a message to retrieve from the Application Queue, this allows us to free up precious CPU usage for other programs to use. PeekMessage() returns immediately weather there are any messages or not, this allows us to utilise the time between messages, for example to render a 3D scene.\
\
8] How we can find out Memory leaks, In what way it can be avoided\
-> Use Permon utility provided by Microsoft\
OR\
To detect a memory leak Create a CMemoryState object and call the Checkpoint member function. This creates the first memory snapshot. After your program performs its memory allocation and deallocation operations, create another CMemoryState object and call Checkpoint for that object. This gets a second snapshot of memory usage. Create a third CMemoryState object and call its Difference member function, supplying as arguments the two previous CMemoryState objects. If there is a difference between the two memory states, the Difference function returns a nonzero value. This indicates that some memory blocks have not been deallocated. This example shows what the code looks like:\
\
	// Declare the variables needed\
	#ifdef _DEBUG\
    	CMemoryState oldMemState, newMemState, diffMemState;\
    	oldMemState.Checkpoint();\
	#endif\
\
    	// Do your memory allocations and deallocations.\
    	CString s("This is a frame variable");\
    	// The next object is a heap object.\
   	CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );\
	#ifdef _DEBUG\
   	newMemState.Checkpoint();\
    	if( diffMemState.Difference( oldMemState, newMemState ) )\
    	\{\
        		TRACE( "Memory leaked!\\n" );\
    	\}\
	#endif\
\
Now that you know a memory leak exists, you can use another member function, CMemoryState::DumpStatistics, to  HYPERLINK "ms-help://MS.MSDNQTR.v80.en/MS.MSDN.v80/MS.VisualStudio.v80.en/dv_vsdebugnative/html/7e325535-51d5-492e-a794-11697270cd3c.htm" view memory statistics that will help you locate it.\
\
9] Is there any class which is not derived from CObject classes. Not Derived from CObject are\
\
------------------\
Simple Value Types\
------------------\
CFileTime\
CFileTimeSpan\
CPoint\
CRect\
CSize\
CSimpleStringT\
|__CStringT\
   |_CFixedStringT\
CTime\
CTimeSpan\
---------------\
Support Classes\
---------------\
CCmdUI\
|_COleCmdUI\
CDaoFieldExchange\
CDataExchange\
CDBVariant\
CFiledExchange\
CImage\
COccManager\
COleDataObject\
COleDispatchDriver\
CPropExchange\
CRecentFileList\
CRectTracker\
CWaitCursor\
-------------------\
Internet Server API		\
--------------------\
CHttpArgList\
CHtmlStream\
CHttpFilter\
CHttpFilterContext\
CHttpServer\
CHttpServerContext\
----------------------------\
Run-Time Object Model Support\
------------------------------\
CArchive\
CDumpContext\
CRuntimeClass\
----------\
Structures\
----------\
CCreateContext\
CHttpArg\
CMemoryState\
COleSafArray\
CPrintInfo\
\
-------------------------\
TypedTemplate Collections\
--------------------------\
CTypedPtrArray\
CTypedPtrList\
CTypedPtrMap\
-----------------\
OLE Type wrappers\
-----------------\
CFontHolder\
CPictureHolder\
--------------------\
OLE Automation Types\
--------------------\
COleCurency\
COleDateTime\
COleDateTimeSpan\
COleVariant\
----------------\
Synchronization\
----------------\
CMultiLock\
CSingleLock\
\
10] How do u identify RTTI in vc++\
-> Check if class is derived directly or indirectly from CObject. CObject provides facility of RTTI check to its derived classes.\
\
&#61558;	  DECLARE_DYNAMIC and IMPLEMENT_DYNAMIC, permit run-time access to the class name and its position in the \
hierarchy. This, in turn, allows meaningful diagnostic dumping.\
\
&#61558;	  CObject::IsKindOf function to determine the class of your objects at run time.\
\
11] What is the difference between the ASSERT and VERIFY macros?\
->ASSERT() macro works in the Debug builds. VERIFY() macro works in Release builds.\
\
12] What is subclassing?\
-> Subclassing is a technique that allows an application to intercept and process messages sent or posted to a particular window before the window has a chance to process them. This is typically done by replacing the Window Procedure for a window with application-defined window \
procedure. I will divide this article into 3: \
\
Subclassing in SDK programs, \
Subclassing in MFC programs, \
Reflected messages\
\
Subclassing a window control is not the same as subclassing a C++ class. Subclassing a control means you replace some or all of the message handlers of a window with your own. You effectively hijack the control and make it behave the way you want, not the way Windows wants. This allows you to take a control that is almost, but not quite, what you want, and make it perfect. \
\
There are two types of subclassing: instance subclassing and global subclassing. Instance subclassing is when you subclass a single instance of a window. Global subclassing subclasses all windows of a particular type with your own version. We'll only discuss single instance here.\
\
To subclass a control we need to create a new class that handles all the windows messages we are interested in. Since we are lazy it's best to minimise the number of messages you actually have to deal with, and the best way of doing this is by deriving your class from the control class you are subclassing. In our case CButton.\
\
Lets assume we want to do something bizarre like make the button glow bright yellow everytime the mouse moves over it. Stranger things have been done. First thing we do is use ClassWizard to create a new class derived from CButton called CMyButton.\
\
Deriving from CButton within the MFC framework has a lot of advantages, with the biggest one being we don't actually have to add a single line of code for our class to be a fully functioning windows control. If we wished we could move onto the next step and subclass a button control with our new class and we would have a perfectly functioning, though somewhat boring, button control. This is because MFC implements default handlers for all it's messages, so we can simply pick the ones we are interested in, and ignore the others.\
\
BEGIN_MESSAGE_MAP(CMyButton, CButton)\
    //\{\{AFX_MSG_MAP(CMyButton)\
    ON_WM_MOUSEMOVE()\
    ON_WM_TIMER()\
    //\}\}AFX_MSG_MAP\
END_MESSAGE_MAP()\
\
/////////////////////////////////////////////////////////////////////////////\
// CMyButton message handlers\
\
void CMyButton::OnMouseMove(UINT nFlags, CPoint point) \
\{\
    // TODO: Add your message handler code here and/or call default\
	\
    CButton::OnMouseMove(nFlags, point);\
\}\
\
void CMyButton::OnTimer(UINT nIDEvent) \
\{\
    // TODO: Add your message handler code here and/or call default\
	\
    CButton::OnTimer(nIDEvent);\
\}\
\
The message map entries (in the BEGIN_MESSAGE_MAP section) map the windows message to the function. ON_WM_MOUSEMOVE maps WM_MOUSEMOVE to your OnMouseMove function, and ON_WM_TIMER maps WM_TIMER to OnTimer. These macros are defined in the MFC source, but they are not required reading. For this excercise simply have faith that they do their job.\
\
13] What is the size of a process\
-> In Case of 32-bit OS the process gains 4GB and in 64-bit OS the process gains 32GB. But in both the cases, if a single process is currently running it may use the entire memory or else the memory space is equally divided among the running processes.\
\
14] How many types of classes are there, what are that. As far i know following are the types of classes \
-> 1: Base class\
2: Derived Class\
3: Abstract Class \
4: Virtual Class.\
\
OR\
There Are 2 Types of Classes Regarding MFC.\
1.Generic Classes -  Independent Classes\
2.Non-Generic Classes - These Classes are derived From \
CObject\
\
15] What is the size of class\
Variable \'96 4\
Function \'96 4\
Virtual Function \'96 8\
HYPERLINK "http://www.allinterview.com/showanswers/57419.html" http://www.allinterview.com/showanswers/57419.html\
\
\
16] SDI & MDI\
-> The SDI application is typically used when you intend to work with only one data set at a time. For instance, the program notepad.exe is a SDI application.\'a0Word for Windows and the VC++ developer studio are MDI applications. In these you can have several documents opened at once. This is particularly useful when you want to cut and paste between documents.\'a0Another use for MDI applications is to have one document, but several different views open that view the data differently. \'a0Remember that in a dialog app, we had just two main classes.\'a0CWinApp\'a0and\'a0CDialog. Here again we have a\'a0CWinApp\'a0and\'a0The\'a0CDialog\'a0class however is replaced by 3 other classes:\'a0CFrameWnd,\'a0CDocument, and\'a0CView.\
	\
CDocument\'a0is a class that has no display, and typically doesn't react much with the messaging system of windows. It is used as a class to manage your data. MFC will create the code automatically which handles the event of File->Save, File->SaveAs, File->Close, and File->Open. All you need to do is to fill in the blank functions in the\'a0CDocument\'a0class.\
\
Next is the\'a0CView. Most likely you will spend more time writing code to display and interact with the document's data then you will writing any other code. This is where the\'a0CView\'a0comes in. The\'a0CView\'a0is a class derived from\'a0CWnd, which is used for displaying your\'a0CDocument\'a0in some way. It is also one of the places where you can handle events like mouse clicks and what not.\'a0The\'a0CFrameWnd\'a0acts as a way to bridge the gap between your document/view classes and the rest of the application. Do you see that frame which goes all around applications boarders? That is the Main Frame window of the application. The title bar, the menu, the scroll bars, the status bar, and the tool bars are all part of the main frame window in an SDI application.\'a0 You typically put the code to handle these objects in the\'a0CFrameWndclass. The\'a0CFrameWnd\'a0class is the main window of the application. The\'a0CView\'a0class is typically a child window of the\'a0CFrameWnd. (For the most part, the child/parent window relations just tell windows what windows are 'stuck' to what other windows. If you move a parent window, all of the children will move also. If you destroy a parent window, all of the children will be destroyed. Etc.) You should have a pretty good idea now of how SDI applications are constructed. MDI applications are similar, but there can be several\'a0CDocument\'a0classes in existence at the same time and there is an added class called\'a0CChildFrame\'a0which acts as a connection between the\'a0CView\'a0and the\'a0CFrameWnd.\
\
17] Inside the Message Map\
-> The message map macros\'a0DECLARE_MESSAGE_MAP,\'a0BEGIN_MESSAGE_MAP, and\'a0END_MESSAGE_MAP\'a0are defined in\'a0AFXWIN.H. If you are curious, you can find this file in the\'a0VC98\\MFC\\INCLUDE\'a0subdirectory under the directory where Visual C++ was installed.\
The\'a0DECLARE_MESSAGE_MAP\'a0macro is declared like this:\
\
#ifdef _AFXDLL\
#define DECLARE_MESSAGE_MAP()\'a0\
private:     static const AFX_MSGMAP_ENTRY _messageEntries[];\'a0\
protected:     static AFX_DATA const AFX_MSGMAP messageMap;    \'a0\
static const AFX_MSGMAP* PASCAL _GetBaseMessageMap();    \'a0\
virtual const AFX_MSGMAP* GetMessageMap() const; \
\
#else\
#define DECLARE_MESSAGE_MAP()\'a0\
private: \}\
    static const AFX_MSGMAP_ENTRY _messageEntries[];\'a0\
protected:     static AFX_DATA const AFX_MSGMAP messageMap;    \'a0\
virtual const AFX_MSGMAP* GetMessageMap() const;\'a0\
#endif\
In short,\'a0DECLARE_MESSAGE_MAP\'a0defines functions to return the class's message map (GetMessageMap()), and that of its base class (_GetBaseMessageMap()), as well as an\'a0AFX_MSGMAP\'a0structure. This structure consists primarily of an array of\'a0AFX_MSGMAP_ENTRY\'a0structures (_messageEntries[]).\
The\'a0BEGIN_MESSAGE_MAP\'a0macro is defined like this:\
#ifdef _AFXDLL\
#define BEGIN_MESSAGE_MAP(theClass, baseClass)    \'a0\
const AFX_MSGMAP* PASCAL theClass::_GetBaseMessageMap()        \'a0\{ return &baseClass::messageMap; \}    \'a0\
const AFX_MSGMAP* theClass::GetMessageMap() const         \{ return &theClass::messageMap; \}    \'a0\
AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap =     \{ &theClass::_GetBaseMessageMap, &theClass::_messageEntries[0] \};    \'a0\
AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] =     \{ \
#else\
#define BEGIN_MESSAGE_MAP(theClass, baseClass)    \'a0\
const AFX_MSGMAP* theClass::GetMessageMap() const         \{  return &theClass::messageMap; \}    \'a0\
AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap =     \{  &baseClass::messageMap, &theClass::_messageEntries[0] \};    \'a0\
AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] =     \{ #endif\
The\'a0BEGIN_MESSAGE_MAP\'a0macro implements the\'a0GetMessageMap()\'a0and _GetBaseMessageMap()\'a0functions, then begins initializing the\'a0_messageEntries[]\'a0array. The initializer list is left without a closing brace, leaving\'a0END_MESSAGE_MAP\'a0to add an entry that marks the end of the message map and closes the initializer list:\
#define END_MESSAGE_MAP()         \{ 0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 \}     \}; \
Between the\'a0BEGIN_MESSAGE_MAP\'a0and\'a0END_MESSAGE_MAP\'a0macros, you use the message map entry macros, such as\'a0ON_COMMAND, which is actually defined like this:\
#define ON_COMMAND(id, memberFxn)     \{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSig_vv, (AFX_PMSG)&memberFxn \},\
The values specified in the message map macros are used to initialize an\'a0AFX_MSGMAP_ENTRY, which looks like this:\
struct AFX_MSGMAP_ENTRY\
\{\
    UINT nMessage;  // windows message\
    UINT nCode;     // control code or WM_NOTIFY code\
    UINT nID;       // control ID (or 0 for windows messages)\
    UINT nLastID;   // used for entries specifying a range of control id's\
    UINT nSig;      // signature type (action) or pointer to message #\
    AFX_PMSG pfn;   // routine to call (or special value)\
\};\
The first four elements are used by MFC to check whether this message map entry applies to the Windows message that is being dispatched. The last two elements specify information about the handler function to be called.\'a0pfn\'a0is a pointer to the function to call, and\'a0nSig\'a0is a special signature type, which MFC uses to specify the return type and parameters that will be passed to the function specified by\'a0pfn. The values used for\'a0nSig\'a0are defined in the\'a0AfxSig\'a0enum type in Afxmsg_.h. This file also lists the function prototypes that should be used to correspond with each\'a0nSig\'a0value.\
\
If you are ever unsure of what form a handler function for a given message map macro should take, you can look up the macro\'97\
for example,\'a0ON_COMMAND\'97in Afxmsg_.h, see that it uses\'a0AfxSig_vv, then find the definition of\'a0AfxSig_vv\'a0to find that your handler function should return\'a0void\'a0and take no parameters.\
\
Using\'a0ClassWizard\'a0to add your handler functions will save you this trouble in most cases; however, there are certain message map entries that\'a0ClassWizard\'a0does not support, such as\'a0ON_COMMAND_RANGE\'a0or\'a0ON_THREAD_MESSAGE.\
Implementing Handler Functions\
\
When you add handler functions with\'a0ClassWizard, your handler function will be created for you, with the proper parameters and return type. If you create your message map en tries and corresponding handler functions yourself, be very careful to declare your handler function with the parameters and return type that the message map entry expects. Failure to do so will result in a corrupted stack at some point and can cause big headaches.\
PreTranslateMessage()\
In most cases, the message pump receives messages and dispatches them by way of message maps, as you saw in the previous example. However, if you find that you need to intercept messages prior to the normal dispatch process, MFC offers a way to do this\'97the\'a0PreTranslateMessage()\'a0function.\
You can override the\'a0PreTranslateMessage()\'a0member function in any class derived from\'a0CWnd,\'a0CWinApp, or\'a0CWinThread. The function takes a pointer to an\'a0MSG\'a0structure and returns a\'a0BOOL. If\'a0PreTranslateMessage()\'a0returns\'a0TRUE, MFC will assume that you have handled the message. If it returns\'a0FALSE, MFC assumes that you have elected not to handle it and will proceed with its normal dispatch process.\
\
18] What is the use of\'a0AFX_MANAGE_STATE?\
-> We are familiar with\'a0Dynamic Link\'a0Libraries\'a0(DLLs)\'a0and most of our daily\'a0application development activities\'a0are using it. If you have an exported function in DLL and you\'a0don\'92t use any resources from the DLL\'a0itself\'a0 then\'a0you could invoke it from an executable module and it will work fine.\'a0But you want to launch a\'a0dialog from the DLL module and which is from\'a0it\'92s own resource part. What will happen if you invoke the domodal of a dialog from any of the exported function in the DLL. No doubt, the domodal will return -1.\'a0\
\
\'a0Actually what is happening here, once we try yo launch a dialog from the DLL from its own resource \'96 but the application holds the resource handle of the main application. So we need to switch the module state for the correct handle to be used. We can do this by adding the following code to the beginning of the exported function in the DLL,\
\
AFX_MANAGE_STATE( AfxGetStaticModuleState() );\
\
This swaps the current module state with\'a0 the state returned fromAfxGetStaticModuleState( )\'a0until the end of the current scope. This is a macro used to protect an exported function in a DLL.\
\
\
\
SQL\
What is SQL?\
SQL stands for Structured Query Language \
SQL lets you access and manipulate databases \
SQL is an ANSI (American National Standards Institute) standard \
What Can SQL do?\
SQL can execute queries against a database \
SQL can retrieve data from a database \
SQL can insert records in a database \
SQL can update records in a database \
SQL can delete records from a database \
SQL can create new databases \
SQL can create new tables in a database \
SQL can create stored procedures in a database \
SQL can create views in a database \
SQL can set permissions on tables, procedures, and views \
\
The following SQL statement will select all the records in the "Persons" table:\
SELECT * FROM Persons\
\
SQL DML and DDL\
SQL can be divided into two parts: The Data Manipulation Language (DML) and the Data Definition Language (DDL).\
\
The query and update commands form the DML part of SQL:\
SELECT - extracts data from a database \
UPDATE - updates data in a database \
DELETE - deletes data from a database \
INSERT INTO - inserts new data into a database \
\
The DDL part of SQL permits database tables to be created or deleted. It also define indexes (keys), specify links between tables, and impose constraints between tables. The most important DDL statements in SQL are:\
CREATE DATABASE - creates a new database \
ALTER DATABASE - modifies a database \
CREATE TABLE - creates a new table \
ALTER TABLE - modifies a table \
DROP TABLE - deletes a table \
CREATE INDEX - creates an index (search key) \
DROP INDEX - deletes an index \
\
SELECT LastName,FirstName FROM Persons\
SELECT DISTINCT City FROM Persons\
SELECT * FROM Persons WHERE City='Happy'\
SELECT * FROM Persons WHERE Year=1965\
\
Operators Allowed in the WHERE Clause\
With the WHERE clause, the following operators can be used:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clcbpat15 \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clcbpat15 \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Operator\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Description\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 =\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Equal\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 <>\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Not equal\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 >\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Greater than\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 <\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Less than\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 >=\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Greater than or equal\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 <=\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Less than or equal\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 BETWEEN\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Between an inclusive range\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LIKE\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Search for a pattern\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth4428\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth4320\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 IN\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 If you know the exact value you want to return for at least one of the columns\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Note: In some versions of SQL the <> operator may be written as !=\
SELECT * FROM Persons WHERE FirstName='Tove' AND LastName='Svendson'\
SELECT * FROM Persons WHERE FirstName='Tove' OR FirstName='Ola'\
SELECT * FROM Persons WHERE LastName='Svendson' AND (FirstName='Tove' OR FirstName='Ola')\
SELECT * FROM Persons ORDER BY LastName\
SELECT * FROM Persons ORDER BY LastName DESC\
\
Now we want to insert a new row in the "Persons" table.\
INSERT INTO Persons VALUES (4,'Nilsen', 'Johan', 'Bakken 2', 'Stavanger')\
\
The following SQL statement will add a new row, but only add data in the "P_Id", "LastName" and the "FirstName" columns:\
INSERT INTO Persons (P_Id, LastName, FirstName) VALUES (5, 'Tjessem', 'Jakob')\
\
UPDATE Persons SET Address='Nissestien 67', City='Sandnes' WHERE LastName='Tjessem' AND FirstName='Jakob'\
\
Notice the WHERE clause in the DELETE syntax. The WHERE clause specifies which record or records that should be deleted. If you omit the WHERE clause, all records will be deleted!\
\
DELETE FROM Persons WHERE LastName='Tjessem' AND FirstName='Jakob'\
\
SELECT * FROM customers WHERE companyname LIKE 'a%'\
\
SQL JOIN\
The JOIN keyword is used in an SQL statement to query data from two or more tables, based on a relationship between certain columns in these tables.\
Tables in a database are often related to each other with keys.\
A primary key is a column (or a combination of columns) with a unique value for each row. Each primary key value must be unique within the table. The purpose is to bind data together, across tables, without repeating all of the data in every table.\
Different SQL JOINs\
Before we continue with examples, we will list the types of JOIN you can use, and the differences between them.\
JOIN: Return rows when there is at least one match in both tables \
LEFT JOIN: Return all rows from the left table, even if there are no matches in the right table \
RIGHT JOIN: Return all rows from the right table, even if there are no matches in the left table \
FULL JOIN: Return rows when there is a match in one of the tables \
SQL INNER JOIN Keyword\
The INNER JOIN keyword return rows when there is at least one match in both tables.\
PS: INNER JOIN is the same as JOIN.\
The "Persons" table:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Address\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 City\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Timoteivn 10\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Svendson\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Tove\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Borgvn 23\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Storgt 20\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Stavanger\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The "Orders" table:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 O_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 4\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 5\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 34764\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 15\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Now we want to list all the persons with any orders.\
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\uc0\u8232 FROM Persons\u8232 INNER JOIN Orders\u8232 ON Persons.P_Id=Orders.P_Id\u8232 ORDER BY Persons.LastName\
The result-set will look like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The INNER JOIN keyword return rows when there is at least one match in both tables. If there are rows in "Persons" that do not have matches in "Orders", those rows will NOT be listed.\
SQL LEFT JOIN Keyword\
The LEFT JOIN keyword returns all rows from the left table (table_name1), even if there are no matches in the right table (table_name2).\
The "Persons" table:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Address\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 City\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Timoteivn 10\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Svendson\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Tove\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Borgvn 23\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Storgt 20\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Stavanger\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clcbpat15 \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clcbpat15 \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clcbpat15 \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The "Orders" table:O_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 4\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clmgf \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clmrg \clvertalc \clshdrawnil \clwWidth5184\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 5\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 34764\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 15\cell 
\pard\intbl\itap1\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\uc0\u8232 FROM Persons\u8232 LEFT JOIN Orders\u8232 ON Persons.P_Id=Orders.P_Id\u8232 ORDER BY Persons.LastName\
The result-set will look like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Svendson\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Tove\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \'a0\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The LEFT JOIN keyword returns all the rows from the left table (Persons), even if there are no matches in the right table (Orders).\
The FULL JOIN keyword return rows when there is a match in one of the tables.\
SQL FULL JOIN Example\
The "Persons" table:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clcbpat15 \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Address\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 City\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Timoteivn 10\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Svendson\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Tove\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Borgvn 23\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Sandnes\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth1836\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx1728
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx3456
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5184
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx6912
\clvertalc \clshdrawnil \clwWidth1728\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Storgt 20\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Stavanger\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The "Orders" table:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 O_Id\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 P_Id\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 2\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 3\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 4\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 1\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 5\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 34764\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 15\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\uc0\u8232 FROM Persons\u8232 FULL JOIN Orders\u8232 ON Persons.P_Id=Orders.P_Id\u8232 ORDER BY Persons.LastName\
The result-set will look like this:\

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat15 \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clcbpat15 \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 LastName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 FirstName\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 OrderNo\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 22456\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Hansen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Ola\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 24562\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 77895\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Pettersen\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Kari\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 44678\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Svendson\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 Tove\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \'a0\cell \row

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth2988\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx2880
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth2880\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadl100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \'a0\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \'a0\cell 
\pard\intbl\itap1\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 34764\cell \lastrow\row
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 The FULL JOIN keyword returns all the rows from the left table (Persons), and all the rows from the right table (Orders). If there are rows in "Persons" that do not have matches in "Orders", or if there are rows in "Orders" that do not have matches in "Persons", those rows will be listed as well.\
The SQL UNION Operator\
The UNION operator is used to combine the result-set of two or more SELECT statements.\
Notice that each SELECT statement within the UNION must have the same number of columns. The columns must also have similar data types. Also, the columns in each SELECT statement must be in the same order.\
\
\
\
11.\'a0 Unary and binary operator: non-overloadable operators.\
12.\'a0 Late Binding.\
13.\'a0 Some critical situation on inheritance: Having same variable name in both base and derived class.\
\'a0\
\'a0\
AND FAQs on dlls, static lib, Linking/binding\
\'a0\
1.\'a0\'a0\'a0\'a0\'a0 Introduction on compiling, object code and linking.\
2.\'a0\'a0\'a0\'a0\'a0 Introduction to static and dynamic library.\
3.\'a0\'a0\'a0\'a0\'a0 LoadLibrary, FreeLibrary.\
4.\'a0\'a0\'a0\'a0\'a0 Comparison on Exe and dlls.\
5.\'a0\'a0\'a0\'a0\'a0 Multithreading and multitasking.\
\'a0\
\
\
A.B.\
General Tips To Overcome An Interview\
Campus So what if you are not a mountaineer. Or a keen hiker. You still cannot treat your interview like a careless morning trot along a jogger's path. Your jaw-jaw at the interview table is nothing less than a cautious climb up a mountain trail--which begins around your early childhood and meanders through the years at the academia before reaching a new summit in your career.And as you retrace your steps down memory lane make sure that you post flags at important landmarks of your life and career, so that you can pop them before the interview panel scoops them out of you. You don't want to be at the receiving end, do you?\
Face the panel, but don't fall of the chair in a headlong rush-and-skid attempt to tell your story. Take one step at a time. If you place your foot on slippery ground, you could be ejecting out on a free fall.\
So prepare, fortify your thoughts, re-jig your memory, and script and design your story (without frills and falsity). Without the right preparation and storyboard, you could be a loser at the interview. Here are a few preparation tips that books on interviews sometimes overlook.\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
Before the interview\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0  HYPERLINK "http://www.freshersworld.com/interview/" \\l "top"  INCLUDEPICTURE "http://www.freshersworld.com/img/top.gif" \\* MERGEFORMATINET \
1. Chronological Outline of Career and Education Divide your life into "segments" defining your university, first job, second job. For each stage, jot down :\
The reason for opting certain course or profession; Your job responsibilities in your previous/current job; Reason of leaving your earlier/current job. You should be clear in your mind where you want to be in the short and long term and ask yourself the reason why you would be appropriate for the job you are being interviewed for and how it will give shape to your future course.\
2. Strengths and Weaknesses\
You should keep a regular check on your strengths and weaknesses. Write down three (3) technical and three (3) non-technical personal strengths. Most importantly, show examples of your skills. This proves more effective than simply talking about them. So if you're asked about a general skill, provide a specific example to help you fulfil the interviewer's expectations. It isn't enough to say you've got "excellent leadership skills". Instead, try saying:\
"I think I have excellent leaderships skills which I have acquired through a combination of effective communication, delegation and personal interaction. This has helped my team achieve its goals."\
As compared to strengths, the area of weaknesses is difficult to handle. Put across your weakness in such a way that it at leaset seems to be a positive virtue to the interviewer. Describe a weakness or area for development that you have worked on and have now overcome.\
3. Questions you should be prepared for\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0  HYPERLINK "http://www.freshersworld.com/interview/" \\l "top"  INCLUDEPICTURE "http://www.freshersworld.com/img/top.gif" \\* MERGEFORMATINET \
Tell us about yourself.\uc0\u8232 What do you know about our company?\u8232 Why do you want to join our company?\u8232 What are your strengths and weaknesses?\u8232 Where do you see yourself in the next five years?\u8232 How have you improved the nature of your job in the past years of your working? Why should we hire you?\u8232 What contributions to profits have you made in your present or former company? Why are you looking for a change?\
\uc0\u8232 Answers to some difficult questions :\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0  HYPERLINK "http://www.freshersworld.com/interview/" \\l "top"  INCLUDEPICTURE "http://www.freshersworld.com/img/top.gif" \\* MERGEFORMATINET \
Tell me about yourself ?\uc0\u8232 Start from your education and give a brief coverage of previous experiences. Emphasise more on your recent experience explaining your job profile.\
What do you think of your boss?\uc0\u8232 Put across a positive image, but don't exaggerate.\
Why should we hire you? Or why are you interested in this job?\uc0\u8232 Sum up your work experiences with your abilities and emphasise your strongest qualities and achievements. Let your interviewer know that you will prove to be an asset to the company.\
How much money do you want?\uc0\u8232 Indicate your present salary and emphasise that the opportunity is the most important consideration.\
Do you prefer to work in a group?\uc0\u8232 Be honest and give examples how you've worked by yourself and also with others. Prove your flexibility.\
4. Questions to As\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
\'a0At the end of the interview, most interviewers generally ask if you have any questions. Therefore, you should be prepared beforehand with 2-3 technical and 2-3 non-technical questions and commit them to your memory before the interview.\
Do not ask queries related to your salary, vacation, bonuses, or other benefits. This information should be discussed at the time of getting your joining letter. Here we are giving few sample questions that you can ask at the time of your interview.\
Sample Questions\
Could you tell me the growth plans and goals for the company?\uc0\u8232 What skills are important to be successful in this position?\u8232 Why did you join this company? (optional)\u8232 What's the criteria your company uses for performance appraisal?\u8232 With whom will I be interacting most frequently and what are their responsibilities and the nature of our interaction?\u8232 What is the time frame for making a decision at this position?\u8232 What made the previous persons in this position successful/unsuccessful?\
\'a05. Do your homework\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0  HYPERLINK "http://www.freshersworld.com/interview/" \\l "top"  INCLUDEPICTURE "http://www.freshersworld.com/img/top.gif" \\* MERGEFORMATINET \
\'a0Before going for an interview, find out as much information on the company (go to JobsAhead Company Q and A) as possible. The best sources are the public library, the Internet (you can check out the company's site), and can even call the company and get the required information. The information gives you a one-up in the interview besides proving your content company or position.\
\'a0Clearing the interview isn't necessarily a solitary attempt. Seek assistance from individuals who are in the profession and whose counsel you value most. Be confident in your approach and attitude; let the panel feel it through your demeanour, body language and dressing.\
Getting prepared for your interview is the best way to dig deep and know yourself. You will be surprised that it would breed a new familiarity become more familiar with your own qualifications that will be make you present yourself better. All the best and get ready to give a treat.\
\
Preprocessor\
Q: How to avoid '#include' woes and redefinition errors?\uc0\u8232 \u8232 A: If you declare a class in your code the compiler normally needs to know some information about the used class like e.g. size. But if you just uses a pointer or a reference, the compiler doesn't need to know those information at that point since pointers or references are always the same size (4 bytes on a windows system). So you just need to tell the compiler that there will be a class - in this case called 'CSomeClass' - which will be used later by that declared pointer or reference. In this case you can use the so-called 'forward declaration'...\
code:\
\
\
class CFoo\
\{\
  CSomeClass m_SomeClass;\
\};\
\
\uc0\u8232 In this example you would need to provide the complete definition of 'CSomeClass' since 'CFoo' will create one instance of it. Therefore the compiler needs to know the exact size of the class and how it looks like...\
code:\
\
\
class CSomeClass;\
\
class CFoo\
\{\
  CSomeClass* m_pSomeClass;\
\};\
\
\uc0\u8232 In this case you only have a pointer to 'CSomeClass'. Since the size of a pointer is independent from the size of the object it is pointing to the compiler just needs to know that there is somewhere a class named 'CSomeClass' is defined...\u8232 \u8232 Most of the time forward declarations are used to prevent circular includes. Consider this\
code:\
\
\
// classA.hpp\
#include <classB.hpp>;\
\
class A\
\{\
  B m_ClassB;\
\};\
\
// classB.hpp\
#include <classA.hpp>;\
\
class B\
\{\
  A m_ClassA;\
\};\
\
\uc0\u8232 In this case you will end up with circular includes. While compiling the 'classA.hpp' header file the header file 'classB.hpp' will be included. While compiling 'classB.hpp' header file the 'classA.hpp' will be included. While compiling...\u8232 \u8232 This will give problems even if you use inclusion guards like\
code:\
\
\
#ifndef __CLASS_A_HPP\
#define __CLASS_A_HPP\
\
// Your class declaration\
\
#endif\
\
\uc0\u8232 Therefore it is not necessarely a good idea to include all the needed header files within your header file. Using forward declarations will avoid those circular includes...\
\
\
Q: What are __FILE__ and __LINE__?\uc0\u8232 \u8232 A: __FILE__ and __LINE__ are predefined macros and part of the C standard. During preprocessing, they are replaced respectively by a constant string holding the current file name and by a integer representing the current line number.\u8232 \u8232 There are other preprocessor variables including:\u8232 \u8232 __DATE__ a string literal of the form "Mmm dd yyyy"\u8232 \u8232 __TIME__ a string literal of the form "hh:mm:ss"\u8232 \u8232 __TIMESTAMP__ a string literal of the form "Mmm dd yyyy hh:mm:ss"\
\
\
Q: Why is there no ".h" in the include directive:\
code:\
\
#include <iostream> \
\
\uc0\u8232 \u8232 A: The file "iostream.h" has been deprecate with the new C++ standard. Replacing it is the file "iostream" (without the ".h"). "iostream" is part of the Standard Template Library (commonly refered to the STL) a new addition to the C++ standard.\
\
\
\
Memory management\
Q: What is the difference between delete and delete [] ?\uc0\u8232 \u8232 A: Whenever you allocate memory with new [], you have to free the memory using delete []. When you allocate memory with new, then use delete without the brackets. You use new[] to allocate an array of values (always starting at the index 0).\
code:\
\
\
int *pi = new int; // allocates a single integer\
int *pi_array = new int[10]; // allocates an array of 10 integers\
delete pi;\
pi = 0;\
delete [] pi_array;\
pi_array = 0;\
\
\
\
Q: Why does deleting the following char* cause my program to crash?\
code:\
\
\
char*    a_string = "beware, the end is near!";\
delete[] a_string;\
\
\uc0\u8232 A: Because the memory that a_string points to was not allocated with new. Only delete memory that was allocated with new. In particular, this string is a constant, so you should not delete it. Also beware that you can not use delete to release memory allocated with malloc.\
\
\
Q: Why does declaring double x[500000] cause my program to crash?\uc0\u8232 \u8232 A: Because such a large piece of memory exceeds the stack size (a stack overflow). You need to allocate the memory on the heap instead:\
code:\
\
\
double *x = new double[500000];\
\
\uc0\u8232 Don't forget to delete the memory (with delete[]) after you are finished with it to avoid memory leaks.\
\
\
Q: What is the difference between const char* and char* const?\uc0\u8232 \u8232 A: char* const declares a constant pointer which has both read and write access to a character (or character array). The pointer itself is a constant and you can not change it. Like all other constant variables, you must initialize it with a constant value at the same time when it is declared:\
code:\
\
\
char buffer[80];\
char* const pBuffer = buffer;\
\
\uc0\u8232 \u8232 const char* declares a pointer to a constant character (or a constant character array). The pointer can be changed, but the character (or array) to which it points can not be changed.\
\
\
Q: What is the purpose of a const reference (const T&)?\uc0\u8232 (Isn't a reference type only useful when its value can be changed?)\u8232 A: Passing by const reference avoids creating a temporary object (thus copying) and thus can vastly improve performance.\u8232 However passing const references to the standard data types (char, int, long, double, ...) does not result in any performance gain. Usually, these types are passed by value instead.\
\
The rules for initializing references make passing by reference-to-const an efficient and attractive alternative to passing by value. \
As in C, function calls in C++ normally pass arguments by value. For example, given: \
int abs(int i);\uc0\u8232 int n; \
calling abs(n) passes argument n to function abs by value. That is, the program copies the value of n to abs's parameter i each time it makes this call. \
C++ uses pass-by-value even for objects of class types. (In C++, class types include struct and union types.) For example, given some struct type: \
struct gadget\uc0\u8232 \{\u8232 // a whole bunch of fields\u8232 \}; \
and: \
int test(gadget g);\uc0\u8232 gadget x; \
calling test(x) passes argument x by value. Much as before, the program copies x's value to parameter g each time it makes this call. \
For large struct objects, passing by value can be very slow because it copies each byte of the argument to the corresponding byte of the parameter, as if by calling the Standard C memcpy function. The program does not necessarily call memcpy to do the job, but the argument passing mechanism behaves as if it did. Strictly speaking, passing a class object by value in C++ conceptually calls a special function associated with the class called the copy constructor. However, when the class is just a struct as in C, the copy constructor behaves essentially like memcpy. \
You can avoid the cost of copying a large argument by passing it by address rather than by value. You simply change the function declaration to: \
int test(gadget *g); \
and then change the function call to test(&x). Passing &x (the address of x) is often a lot less work than passing an entire copy of x. \
Unfortunately, when you change the parameter type from gadget to "pointer to gadget," you introduce a change in the function's behavior, or at least the possibility of a change. When passing by value, the function only sees a copy of the original gadget, so it cannot change that gadget. In my example, when passing by value, calling test(x) cannot change x. When passing by address, the function can dereference its pointer parameter and store new values into the gadget argument. That is, calling test(&x) might change x. Of course, you can prevent the function from tampering with its argument by using the const qualifier, as in: \
int test(gadget const *g); \
For very large objects, passing by address (with const) is almost always faster than passing by value. For objects of modest size (on the order of eight to 16 bytes), it isn't always clear at the outset whether passing by address will actually be faster than passing by value. It depends on the target machine's architecture and what the function does with the parameter. Sometimes you just have to make your best guess and wait to measure the performance of the running program. If it turns out that you guessed wrong, you may have to rewrite the function. \
Unfortunately, rewriting a function call so that it uses pass-by-address instead of pass-by-value, or vice versa, can be a bona fide maintenance headache. Changing the function declaration from: \
int test(gadget g); \
to: \
int test(gadget const *g); \
isn't much fuss, nor is changing the corresponding function definition. But numerous function calls might be scattered throughout the code, and you have to rewrite all those calls. In some cases, a call such as text(x) becomes test(&x). In others, test(*p) becomes test(p) (where p is a "pointer to gadget"). \
In C++, passing by reference offers an alternative to passing by address. You can declare the test function as: \
int test(gadget const &g); \
In this case, parameter g has type "reference to const gadget." This lets you write the call as test(x), as if it were passing by value, but it yields the exact same performance as if it were passing by address. Again, the const qualifier prevents the function from changing the value of its actual gadget argument. \
\
\
\
Operators\
\
Q: How do I overload the postfix increment and decrement operators? (as in x++ or x-- )?\uc0\u8232 \u8232 A: To specify the postfix increment and decrement operators, you must specify an int as an argument:\
code:\
\
\
class MyClass\
\{\
public:\
    MyClass& operator++();    //Prefix increment operator  (++x)\
    MyClass  operator++(int); //Postfix increment operator (x++)\
\
    MyClass& operator--();    //Prefix decrement operator  (--x)\
    MyClass  operator--(int); //Postfix decrement operator (x--)\
\};\
\
\
\
Q: Someone told me that if I want to increment a variable and that's all, I should use ++x instead of x++. Is this true?\uc0\u8232 \u8232 \u8232 A: If incrementing is all that you want to do (you are not assigning the variable to something else), then yes this is a good practice, especially if you are using the increment operator on a class.\
code:\
\
// Prefix operators are preferred in cases in the following common cases:\
\
for (;checkstate(x);++x) dosomething(x);\
\
++x;\
\
\uc0\u8232 For the standard data types there is usually no performance difference, but for classes there are! The reason is that (for most common implementations of) postfix operators retain a temporary copy of original variable and because the return value is returned by value, not by reference. The following code exemplifies this:\
code:\
\
\
class MyClass\
\{\
public:\
    MyClass& operator++()    //Prefix increment operator  (++x)\
    \{\
        //Perform increment operation\
        return *this;\
    \}\
\
    MyClass  operator++(int) //Postfix increment operator (x++)\
    \{\
        MyClass temp = *this;\
        //Perform increment operation\
        return temp;\
    \}\
\};\
\
\
\
Exception handling\
\
Q: The wrong catch statement catches an exception in the following code! Why?\
code:\
\
\
#include <iostream>\
\
using namespace std;\
\
class A\
\{\
\};\
\
class B : public A\
\{\
\};\
\
int main()\
\{\
    B b;\
\
    try\
    \{\
        throw b;\
    \}\
    catch (A& ea)\
    \{\
        cout << "Caught an instance of A" << endl;\
    \}\
    catch (B& eb)\
    \{\
        cout << "Caught an instance of B" << endl;\
    \}\
    return 0;\
\}\
\
\uc0\u8232 \u8232 A: No, the code works the way it is supposed to. When a thrown class encounters a parent class in an a catch statement, the class will be recast and copied -- you will not be able to recast a caught pointer back to the original type!\u8232 \u8232 Catching happens on a "first come, first serve" basis. The first catch statement that can match will. In order to get the above code to work as expected, the catch statement for the B class needs to occur before the catch statement for the A class:\
code:\
\
\
#include <iostream>\
\
using namespace std;\
\
class A\
\{\
\};\
\
class B : public A\
\{\
\};\
\
int main()\
\{\
    B b;\
\
    try\
    \{\
        throw b;\
    \}\
    catch (B& eb)\
    \{\
        cout << "Caught an instance of B" << endl;\
    \}\
    catch (A& ea)\
    \{\
        cout << "Caught an instance of A" << endl;\
    \}\
    return 0;\
\}\
\
\
\
Structures\
\
Q: How do I write a structure to a file?\uc0\u8232 \u8232 A: You can easily write a structure to a file as long as the structure is what is known as a POD (Plain Old Data) type. This means that all members of the structure must be of a fixed size, which implies that the structure can not contain pointers. This stipulation goes for all members of the structure. Look at these examples:\
code:\
\
\
struct a\
\{\
  int    x;\
  float  f;\
  double d;\
  char   c;\
  char   s[50];\
\};\
\
// OK\
\
\
struct b\
\{\
  int    x;\
  float  f;\
  double d;\
  char   c;\
  char*  s;\
\};\
\
// Wrong! 's' has unknown length; only address of pointer will be written.\
\
\
struct c\
\{\
  int    x;\
  float  f;\
  double d;\
  char   c;\
\
  struct\
  \{\
    char* s;\
  \} e;\
\};\
\
// Wrong! 'e' has a char* member.\
\
\uc0\u8232 So, now hopefully you have a POD data type. We will use 'fstream' to read and write it:\
code:\
\
\
#include <string>\
#include <fstream>\
\
struct s\
\{\
  // Your POD data here\
\};\
\
void write( const std::string& file_name, s& data )\
\{\
  std::ofstream out( file_name.c_str() );\
  out.write( reinterpret_cast<char*>(&s), sizeof(s) );\
\}\
\
void read( const std::string& file_name, s& data )\
\{\
  std::ifstream in( file_name.c_str() );\
  in.read( reinterpret_cast<char*>(&s), sizeof(s) );\
\}\
\
int main()\
\{\
  s myStruct;\
  read( "test.dat", myStruct );\
  write( "test.dat", myStruct );\
\}\
\
\uc0\u8232 This code works fine, but only works for a single type and it does not work for an array. To make this solution more flexible, we will define a template function that will work for any POD structure.\
code:\
\
\
template<typename T>\
void write_pod( std::ofstream& out, T& t )\
\{\
  out.write( reinterpret_cast<char*>(&T), sizeof(T) );\
\}\
\
template<typename T>\
void read_pod( std::ifstream& in, T& t )\
\{\
  in.read( reinterpret_cast<char*>(&T), sizeof(T) );\
\}\
\
\uc0\u8232 So now we have two simple functions that will write and read an arbitrary POD structure. Now, we can easily apply them to our current example, but instead, I will show you how they can be used to write an array to a file. To make this easy, we will make use of the STL algorithm 'for_each' to write.\
code:\
\
\
#include <vector>\
#include <fstream>\
#include <algorithm>\
\
int main()\
\{\
  std::vector<s> myStructs;\
  std::ofstream out( "test.dat" );\
\
  // Fill vector here\
\
  std::for_each( myStructs.begin(), myStructs.end(), std::bind1st( write_pod<s>, out ) );\
\}\
\
\uc0\u8232 or for an array\
code:\
\
\
#include <fstream>\
#include <algorithm>\
\
int main()\
\{\
  s myStructs[20];\
  std::ofstream out( "test.dat" );\
\
  // Fill array here\
\
  std::for_each( myStructs, myStructs + 20, std::bind1st( write_pod<s>, out ) );\
\}\
\
\uc0\u8232 This code works great for writing, but posses a problem when reading; we don't know the size of the array. This is not always a problem - we can just read until we hit the end of the file. But if you need to allocate an array, or want to store several different structs in one file this will not work. It also allows us to optimize our code with 'vector' by presizing the 'vector' before reading. This is a fairly simple fix, we will just write the size before all of our data:\
code:\
\
\
#include <vector>\
#include <fstream>\
#include <algorithm>\
\
int main()\
\{\
  std::vector<s> myStructs;\
  std::ofstream out( "test.dat" );\
\
  // Fill vector here\
\
  write_pod<long>( out, myStructs.size() );\
  std::for_each( myStructs.begin(), myStructs.end(), std::bind1st( write_pod<s>, out ) );\
\}\
\
\uc0\u8232 Notice, that 'write_pod()' can also be used with integral types since they are POD's themselves. Unfortunately, the STL does not have an algorithm that allows us to easily read from a 'vector' into a file. So, we will just use a loop. Here is the method to read a 'vector' of structs from a file, I will templatize it to begin with:\
code:\
\
\
#include <vector>\
#include <fstream>\
\
template<typename T>\
void read_pod_vector( std::ifstream& in, std::vector<T>& vect )\
\{\
  long size;\
\
  read_pod( in, size );\
  vect.resize( size );\
\
  for( int i = 0;i < size;++i )\
  \{\
    T t;\
    read_pod( in, t );\
    vect.push_back( t );\
  \}\
\}\
\
\uc0\u8232 While we're at it, we might as well define a similar function to write a 'vector':\
code:\
\
\
#include <vector>\
#include <fstream>\
#include <algorithm>\
\
template<typename T>\
void write_pod_vector( std::ofstream& out, std::vector<T>& vect )\
\{\
  write_pod<long>( out, myStructs.size() );\
  std::for_each( vect.begin(), vect.end(), std::bind1st( write_pod<T>, out ) );\
\}\
\
\uc0\u8232 So, implementing these functions to read and write a 'vector' we have:\
code:\
\
\
#include <vector>\
#include <fstream>\
\
int main()\
\{\
  std::vector<s> myStructs;\
  std::ofstream out( "test.dat" );\
  std::ifstream in( "test.dat" );\
\
  // Fill vector here\
\
  write_pod_vector( out, myStructs );\
  out.close();\
\
  read_pod_vector( in, myStructs );\
\}\
\
\uc0\u8232 So, now you know how to write a POD structure, or a set of POD structures to a file. What if your structure is not POD? Well, then it becomes a bit more complicated. The approach you would take is the exact same as we took with 'vector', after all 'vector' is a non-POD type and we are writing it to a file. That is, you would write the size of the data before the data so you know how much data to read. You may have noticed that the second parameter to read/write is the size of the data, so you don't need loop through all of your data. I will show you now two examples that use this fact.\u8232 \u8232 Example 1: Optimized vector read/write\
code:\
\
\
#include <vector>\
#include <fstream>\
\
template<typename T>\
void write_pod_vector( std::ofstream& out, std::vector<T>& vect )\
\{\
  long size = myStructs.size();\
\
  write_pod<long>( out, size );\
  out.write( reinterpret_cast<char*>(vect.front()), size * sizeof(T) );\
\}\
\
\uc0\u8232 This example takes advantage of vector's congenious structure and second parameter to write which allows us to write the entire 'vector' with one call. We can do the same thing to read:\
code:\
\
\
#include <vector>\
#include <fstream>\
\
template<typename T>\
void read_pod_vector( std::ifstream& in, std::vector<T>& vect )\
\{\
  long size;\
\
  read_pod( in, size );\
  vect.resize( size );\
  in.read( reinterpret_cast<char*>(vect.front()), size * sizeof(T) );\
\}\
\
\uc0\u8232 Not only do we cut out several lines, but we make our program more effient. My next example will show you to read/write other pointer data. The following structure is used to store a variable length string:\
code:\
\
\
struct str\
\{\
  long  size;\
  char* s;\
\};\
\
\uc0\u8232 Now, here are the read an write methods for this structure.\
code:\
\
\
#include <fstream>\
\
void write_str( std::ofstream& out, str& s )\
\{\
  out.write( reinterpret_cast<char*>(&s.size), sizeof(long) );\
  out.write( s.s, s.size * sizeof(char) );\
\}\
\
void read_str( std::ifstream& in, str& s )\
\{\
  in.read( reinterpret_cast<char*>(&s.size), sizeof(long) );\
  s.s = new char[s.size];\
  in.read( s.s, s.size * sizeof(char) );\
\}\
\
\
\
Q: Why returns 'sizeof()' a bigger size than the member variables actually need?\uc0\u8232 \u8232 A: This is due to structure alignment which aligns the data structure by padding extra bytes so as to optimize for data transfer.\u8232 \u8232 Modern CPUs perform best in data transfer when fundamental types, such as 'int' and 'float', are stored in memory addresses that are multiples of their length. Some CPUs, like x86, also allow unaligned access but at a performance penalty. In other words, it requires extra data transfer when the data is unaligned.\u8232 \u8232 When a C/C++ compiler processes a structure declaration, it adds extra bytes between fields to ensure that they are properly aligned. It also adds extra bytes to the end of the structure so that every element of an array of that structure type, is properly aligned.\u8232 \u8232 As a rule of thumb, to minimize the extra padded bytes needed for the alignment, all fields of the same type should be grouped together. See the following example:\
code:\
\
\
struct MyStructA\
\{\
    char a;\
    char b;\
    int c;\
\};\
\
struct MyStructB\
\{\
    char a;\
    int c;\
    char b;\
\};\
\
// Results from VC6 on x86, it may varies for other CPU/OS/compiler combination.\
int sizeA = sizeof(MyStructA);   // sizeA = 1 + 1 + (2-padding) + 4 = 8\
int sizeB = sizeof(MyStructB);   // sizeB = 1 + (3-padding) + 4 + 1 + (3-padding) = 12\
\
\uc0\u8232 As the C/C++ standard states, the alignment is completely implementation defined, thus, each CPU/OS/compiler combination is free to choose whatever alignment and padding rules it deems best. Although the standard didn't provide any control in customizing the alignment and padding rules, many compilers provide this through non-standard extensions. For example, VC6 provides the  HYPERLINK "http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_predir_pack.asp" \\t "_blank" pragma pack(n) macro.\
\
\
Casting\
\
Q: What are c-style casts ? What is static_cast, dynamic_cast, const_cast and reinterpret_cast ? What is the difference ? Why should I care ?\uc0\u8232 \u8232 A: Casting means you change the representation of a variable by changing its type to a different one. In order to type-cast a simple object to another you use the traditional type casting operator. For example, to cast a floating point number of type 'double' to an integer of type 'int':\
code:\
\
\
int i;\
double d;\
\
i = (int) d;\
\
\uc0\u8232 or also\
code:\
\
\
i = int (d);\
\
\uc0\u8232 This is quite good for basic types that have standard defined conversions, however this operators can also been indiscriminately applied on classes and pointers to classes. ANSI-C++ standard has defined four new casting operators: 'reinterpret_cast', 'static_cast', 'dynamic_cast' and 'const_cast' in order to control these types of conversions between classes...\
code:\
\
\
reinterpret_cast<new_type>(expression)\
dynamic_cast<new_type>(expression)\
static_cast<new_type>(expression)\
const_cast<new_type>(expression)\
\
\uc0\u8232 reinterpret_cast\u8232 \u8232 'reinterpret_cast' casts a pointer to any other type of pointer. It also allows casting from pointer to an integer type and vice versa.\u8232 \u8232 This operator can cast pointers between non-related classed. The operation results is a simple binary copy of the value from a pointer to the other. The content pointed does not pass any kind of check nor transformation between types.\u8232 \u8232 In the case that the copy is performed from a pointer to an integer, the interpretation of its content is system dependent and therefore any implementation is non portable. A pointer casted to an integer enough large to fully contain it can be casted back to a valid pointer.\
code:\
\
\
class A \{\};\
class B \{\};\
\
A * a = new A;\
B * b = reinterpret_cast<B *>(a);\
\
\uc0\u8232 'reinterpret_cast' treats all pointers exactly as traditional type-casting operators do.\u8232 \u8232 \u8232 static_cast\u8232 \u8232 'static_cast' allows to perform any casting that can be implicitly performed as well as also the inverse cast (even if this is not allowed implicitly).\u8232 \u8232 Applied to pointers to classes, that is to say that it allows to cast a pointer of a derived class to its base class (this is a valid conversion that can be implicitly performed) and can also perform the inverse: cast a base class to its derivated class.\u8232 \u8232 In this last case the base class that is being casted is not checked to determine wether this is a complete class of the destination type or not.\
code:\
\
\
class Base \{\};\
class Derived : public Base \{\};\
\
Base *a    = new Base;\
Derived *b = static_cast<Derived *>(a);\
\
\uc0\u8232 'static_cast', aside from manipulating pointers to classes, can also be used to perform conversions explicitly defined in classes, as well as to perform standard conversions between fundamental types:\
code:\
\
\
double d = 3.14159265;\
int    i = static_cast<int>(d);\
\
\uc0\u8232 dynamic_cast\u8232 \u8232 'dynamic_cast' is exclusively used with pointers and references to objects. It allows any type-casting that can be implicitly performed as well as the inverse one when used with polymorphic classes, however, unlike static_cast, dynamic_cast checks, in this last case, if the operation is valid. That is to say, it checks if the casting is going to return a valid complete object of the requested type.\u8232 \u8232 Checking is performed during run-time execution. If the pointer being casted is not a pointer to a valid complete object of the requested type, the value returned is a 'NULL' pointer.\
code:\
\
\
class Base \{ virtual dummy() \{\} \};\
class Derived : public Base \{\};\
\
Base* b1 = new Derived;\
Base* b2 = new Base;\
\
Derived* d1 = dynamic_cast<Derived *>(b1);          // succeeds\
Derived* d2 = dynamic_cast<Derived *>(b2);          // fails: returns 'NULL'\
\
\uc0\u8232 If the type-casting is performed to a reference type and this casting is not possible an exception of type 'bad_cast' is thrown:\
code:\
\
\
class Base \{ virtual dummy() \{\} \};\
class Derived : public Base \{ \};\
\
Base* b1 = new Derived;\
Base* b2 = new Base;\
\
Derived d1 = dynamic_cast<Derived &*>(b1);          // succeeds\
Derived d2 = dynamic_cast<Derived &*>(b2);          // fails: exception thrown\
\
\uc0\u8232 const_cast\u8232 \u8232 This type of casting manipulates the const attribute of the passed object, either to be set or removed:\
code:\
\
\
class C \{\};\
\
const C *a = new C;\
\
C *b = const_cast<C *>(a);\
\
\uc0\u8232 Neither of the other three new cast operators can modify the constness of an object.\u8232 \u8232 Note: const_cast can also change the volatile qualifier on a type.\
\
\
Callbacks\
\
Q: How to use class member functions as callbacks?\uc0\u8232 \u8232 A:The problem is that every callback function has its own prototype, which determines the parameters that gets passed from the operating system to it.\u8232 \u8232 In C++ every member function has a hidden parameter - the so-called 'this' pointer which will be automatically passed to the function. C++ is able to associate a function with a particular instance of an object by means of the 'this' pointer. Member functions access member variables through the 'this' pointer...\
code:\
\
\
class CFoo\
\{\
public:\
  void Function()\
  \{\
    m_iInteger = 0;\
  \}\
\
private:\
  int m_iInteger;\
\};\
\
\uc0\u8232 If you compile this code it will be compiled as\
code:\
\
\
class CFoo\
\{\
public:\
  void Function(CFoo *this)\
  \{\
    this->m_iInteger = 0;\
  \}\
\
private:\
  int m_iInteger;\
\};\
\
\uc0\u8232 The operating system does not call callback functions through objects therefore it cannot handle the automatically added 'this' pointer... To get a member functions working as a callback routine you need to tell the compiler explicitly not to expect a 'this' pointer. To avoid the automatic 'this' pointer you have two possibilities:\u8232 \u8232 - Non-member functions\u8232 - Static member functions\u8232 \u8232 Non-member functions are not part of a class and therefore do not have a 'this' pointer. Static member functions do not receive a 'this' pointer either...\u8232 \u8232 Therefore if you want to use a member function as a callback routine you need to declare it as 'static'...\u8232 \u8232 For more information you might take a look at:\u8232 \u8232 -  HYPERLINK "http://support.microsoft.com/default.aspx?scid=KB;EN-US;q102352&" \\t "_blank" 'INFO: Passing a Pointer to a Member Function to the Win32 API'\u8232 -  HYPERLINK "http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/msdn_callb.asp" \\t "_blank" 'Calling All Members: Member Functions as Callbacks'\
\
\
Templates\
\
Q: I have the following code:\
code:\
\
\
// In foo.h\
\
template <typename T>\
T foo(const T& t);\
\
// end of foo.h\
//------------------------------------------------\
\
// In foo.cpp\
\
template <typename T>\
T foo(const T& t)\
\{\
    // function body\
\}\
\
// end of foo.cpp\
//------------------------------------------------\
\
// In main.cpp\
\
#include "foo.h"\
int main()\
\{\
    int i = 1;\
    int j = foo(i);\
\}\
\
\uc0\u8232 But when I compile it, the linker tells me that "foo" (in whatever way the complier mangles foo<int>) is an unresolved external symbol.\u8232 \u8232 \u8232 A: There are actually two solutions to this problem - the "correct" one and the one that works. But before getting to that we need to understand why there is a problem.\u8232 \u8232 The thing to understand about template code is that it's, well, a template. It's not real code. It's like when you have a letter template in your word processor: it's not a real letter until you fill in details like the person it's addressed to. In the example given, the compiler can't compile the definition of foo in "foo.cpp" because it doesn't know what T is. Until it knows that, it can't decide whether or not the operation you perform using T objects are valid or not. For example foo might call a specific member function of T called, say, bar(). But T is only a placeholder. Until you call foo with a specific type, how can the compiler know whether or not the code is valid?\u8232 \u8232 So it comes down to this: templated functions (and classes) don't actually exist until you use them. And in order for the compiler to generate the real code for the function (or class), it has to have the complete definition of the template available at the point of use. If the full definition is not available, the compiler will assume that it's been defined somewhere else and just plant code for the call. And here's the problem with the example above: at the time foo is used (in main()), the compiler only has the declaration of foo available, so it assumes that foo<int> (because that's the instantiation that's wanted) is defined elsewhere. But the definition is in foo.cpp, and there is no use of foo<int> there, so the compiler won't bother generating it. And so we get to the situation that compiling main() plants a call to foo<int>, but compiling foo.cpp produces nothing. And that leads to an unresolved external reference.\u8232 \u8232 \u8232 The "correct" solution.\u8232 \u8232 I call this correct, because it keeps the example code the way it is laid out. The standard defines a keyword export that is designed for just this situation. By defining foo in foo.cpp with export:\
code:\
\
\
template <typename T>\
export T foo(const T& t)\
\{\
    // definition\
\}\
\
\uc0\u8232 The definition becomes available to the compiler whilst it is comping main.cpp, and so it now generates the code for foo<int> and the external is resolved.\u8232 \u8232 \u8232 The solution that works.\u8232 \u8232 Unfortunately, not many compilers support export, so the "correct" solution is more likely to produce a compilation error that it is to solve the problem. So the practical solution is define the function in the header file as an inline function:\
code:\
\
\
// foo.h\
template <typename T>\
inline T foo(const T& t)\
\{\
    // definition\
\}\
\
\uc0\u8232 This way, because it's in the header file, the compiler can see it at the point of use and can generate the appropriate code and the external is resolved.\u8232 \u8232 For those who think that's a bit ugly, and would like a solution that's half-way to the "correct" one (for that day when their compiler supports export), put the inine definition into a file called "foo.inl" and #include "foo.inl" at the end of the original foo.h. Then, when you get your new compiler, rename foo.inl to foo.cpp, change inline to export and remove the #include from foo.h.\
\
\
Polymorphism\
\
Q: How do we use virtual functions?\uc0\u8232 \u8232 A: The FAQ  HYPERLINK "http://www.codeguru.com/forum/showthread.php?s=&threadid=256008" \\t "_blank" "What is polymorphism?" covers why we have virtual functions. In this FAQ, I want to examine how we use them - in Scott Meyers's words "say what you mean, understand what you are saying".\u8232 \u8232 There are nine ways that you can declare a virtual function: it can be plain, pure or pure-with-a-body. Each of these three can be declared public, private or protected. Thus, nine declarations, but what does each one say? What do we mean when we declare a private, pure virtual function?\u8232 \u8232 "Hold on", I hear a voice from the back cry, "what do you mean by pure-with-a-body?". Well, it's one of those lesser-known facts of the language that a pure virtual function can have a definition (or body). After all, the pure specifier (the "= 0" bit) only says that this class cannot be instantiated - it does not say "this function cannot be implemented here". One of the simplest ways of making a class abstract (cannot be instantiated) is to declare the destructor pure - but destructors simply have to have a body.\u8232 \u8232 So, let's look at the various declarations and see what the programmer who uses each is saying. The first thing to point out is that, since the virtual mechanism works down inheritance hierarchies, there is not usually much difference in meaning between a public function and a protected one - it's just a matter of outside visibility rather than "meaning" in the sense that I'm covering it here.\u8232 \u8232 Plain Old Virtual Functions: Basically, these are saying "this function has a default implementation. If you do not override it, then the default will be used."\u8232 \u8232 If the function is non-private, then derived classes may also use it as part of their processing.\
code:\
\
\
class foo\
\{\
public:\
  virtual void povf(); // has a body somewhere\
\};\
\
class bar : public foo\
\{\
public:\
  void povf()\
  \{\
    foo::povf();\
    // do some more processing\
  \}\
\};\
\
\uc0\u8232 So here, foo::f() does something (probably involving foo's private data). The function is virtual because the programmer recognised that derived classes may have extra work to do with their own private data. If bar had nothing extra to do, then it could just ignore povf and let the default action happen.\u8232 \u8232 A private Plain Old Virtual Function, on the other hand, cannot be re-used by derived classes. It's saying "here is a default action: if you choose to override it, you may not incorporate into your override". Ok, let's admit it, the need for this is rare, but it's not unknown.\u8232 \u8232 Pure virtual functions:\u8232 \u8232 These are saying "here is behaviour that derived classes must implement."\u8232 \u8232 If there is no body for the function, then it is also saying "there is no sensible implementation for this function at this level." In other words, the class that declares the function is at a high level of abstraction and contains insufficient specialised information to provide an implementation. For example:\
code:\
\
\
class bird\
\{\
public:\
  virtual void fly() = 0;  // No body\
\};\
\
\uc0\u8232 At the level of "bird", there is no way that it can implement fly(), since we don't know what type of bird we really are. It's not until we've derived "sparrow" and "albatross" from bird that we can supply an implementation.\u8232 \u8232 ---- A brief digression\u8232 \u8232 By the way, on this definition, emus, ostriches, kiwis, etc. are not birds. Class bird defines the ability to fly as a prerequisite for "bird-hood". Do not be tempted to do this:\
code:\
\
\
class ostrich : public bird\
\{\
public:\
  void fly()\
  \{\
    // throw an exception or something\
  \}\
\};\
\
\uc0\u8232 This is bad programming practice. Public inheritance means IS-A. If your derived class cannot implement a virtual function in its base class's interface, then it is not IS-A, and you should look at reviewing the design. So, to count ostriches as birds, we need:\
code:\
\
\
class bird\
\{\
public:\
  // something\
\};\
\
class flying_bird : public bird\
\{\
public:\
  virtual void fly() = 0;\
\};\
\
\uc0\u8232 now, "ostrich" derives from "bird", while "sparrow" derives from "flying_bird".\u8232 \u8232 ---- End of digression\u8232 \u8232 How does access control affect this? Well, basically, there's no point in declaring a pure virtual function with no body in the protected section. The only reason for making it protected would be to allow a derived class to call it, but there's nothing to call, so make it public or private depending on whether or not the outside world needs to call it.\u8232 \u8232 Pure virtuals that do have a body, on the other hand are saying: "here is a default implementation. If you wish to use it, you must do so explicitly". Note the difference here compared with the Plain Old Virtual Function. With a POVF, you might get the default action by accident, because you forgot to write your override. By making the function pure, you can only get the default implementation deliberately:\
code:\
\
\
class foo\
\{\
public:\
  virtual void pvfwb() = 0;\
\};\
\
void foo::pfvwb()\
\{\
  // something\
\}\
\
class bar1 : public foo\
\{\
  // ...\
\};\
\
class bar2 : public foo\
\{\
public:\
  void pvfwb()\
  \{\
    foo::pvfwb();\
  \}\
\};\
\
\uc0\u8232 "bar1" does not override pvfwb(), so it remains an abstract class. "bar2", however, reuses the default implementation deliberately. The meaning of the coder is clear.\u8232 \u8232 And access control? Well, there seems little point in making one of these private. Only the class itself (and its friends) could call it, and then it would have to qualify the call:\
code:\
\
\
class foo\
\{\
public:\
  void f() \{ foo::g(); \}\
\
private:\
  virtual void g() = 0;\
\};\
\
void foo::g()\
\{\
  // ...\
\}\
\
\uc0\u8232 There seems little point in making it virtual, in this case.\u8232 \u8232 Finally, what do non-virtual functions say?\u8232 \u8232 A non-virtual function says "the implementation of this behaviour does not change in derived classes". A non-virtual function is invariant over specialisation: derived classes inherit behaviour and implementation. Do not override a non-virtual function in a derived class - you will pay dearly in lost maintenance time if you do.\
\
Q: What is polymorphism?\uc0\u8232 \u8232 A: I'm glad you asked me that...\u8232 \u8232 Without going into great detail, polymorphism is a mechanism that allows you to implement a function in different ways. For example, you might be modelling birds, and you want them to fly. Some birds flap their wings like crazy, others glide majestically. However, the function that moves a bird from one place to another doesn't care how the bird flies, only that it does fly. This is an important principle to grasp - the what is important, the how is irrelevant. So your "migrate" function could be used with any bird class that is capable of flying, whether it's a sparrow or an albatross. What we're saying, then, is that these birds share the ability to fly, though the way they fly may differ. The "ability to fly" is an abstraction. Note again the distinction between what it does and how it does it. The abstraction says what it does: it says nothing about how it does it. We represent that in C++ with the "pure virtual function":\
code:\
\
\
class bird\
\{\
public:\
  virtual void fly() = 0;\
\};\
\
\uc0\u8232 What this (abstract) class is saying is "all birds can fly". (Note that, on this definition, emus and ostriches are not birds because they can't fly. This is a very important point, but unfortunately outside the scope of this FAQ.)\u8232 \u8232 Your migrate function now only needs to know about the "bird" class in order to be written:\
code:\
\
\
void migrate(bird* tweetiepie)\
\{\
  // ...\
  tweetiepie->fly();\
  // ...\
\}\
\
\uc0\u8232 So far, so good. But "bird" only defines the "what" part - it says nothing about the "how". And that's another thing the pure virtual function does: you cannot create an object of type "bird" - you've got to be more specific and create a particular kind of bird. This is where inheritance and polymorphism come in: if we want to do some useful work, we need some real birds:\
code:\
\
\
class swallow : public bird\
\{\
public:\
  virtual void fly()\
  \{\
    flap_wings_like_crazy();\
  \}\
\};\
\
class albatross : public bird\
\{\
public:\
  virtual void fly()\
  \{\
    glide_majestically_over_the_waves();\
  \}\
\};\
\
\uc0\u8232 Because we've derived both of these from the abstract class bird, we can use one wherever a bird is expected. Specifically, we can give migrate() a swallow or an albatross, and it will still work.\
code:\
\
\
swallow s;\
albatross a;\
\
migrate(&s);\
migrate(&a);\
\
\uc0\u8232 When the swallow is passed to migrate, the call to fly() in there will result in "flap_wings_like_crazy", but when the albatross is passed in, the same call will result in "glide_majestically_over_the_waves". \u8232 \u8232 And that's polymorphism.\
\
\
Random numbers\
\
Q: Why does my random number generator always return the same set of numbers?\uc0\u8232 \u8232 A: A random number generator needs to be seeded before use, or it will always generate the same list of random numbers. For example the C 'time()' function can be used for this:\
code:\
\
\
srand(time(NULL));\
\
\uc0\u8232 One should generally avoid using 'clock()' to initialize random numbers, since 'clock()' returns the amount of time the current thread has been running, generally a number close to zero.\u8232 \u8232 Good seeds will involve more "random" bits. One way this can be accomplished is by using higher resolution timers such as a performance counter or an RDTSC value. Better seeds may mix the least significant bits of different timers. The best seeds are produced from truely random sources. If a computer is connected to the internet, truely random seeds can be obtained from sites like  HYPERLINK "http://www.random.org" \\t "_blank" random.org.\
\
Q: What are good random number generators?\uc0\u8232 \u8232 A: There are two common problems when using pseudo-random number generators (PRNGs):\
\
The PRNG does not get seeded. Please see related  HYPERLINK "http://www.codeguru.com/forum/showthread.php?s=&threadid=284875" \\t "_blank" FAQ for discussion on this topic.\
A poor PRNG is being used.\
\uc0\u8232 This FAQ addresses the second problem. \u8232 \u8232 Often people use the C library function 'rand()' for random number generation. And quite often, the implementation for 'rand()' is not very good - the range of numbers is too small, the period before repetition is too small, and/or other problems.\u8232 \u8232 Better PRNGs can be found in a variety of sources. The most popular is the "Mersenne Twister". The "Mersenne Twister" and other good PNRGs can be found in the  HYPERLINK "http://www.boost.org/libs/random/" \\t "_blank" Boost library and the  HYPERLINK "http://www.gnu.org/software/gsl" \\t "_blank" GNU Scientific Library).\u8232 \u8232 Another good resource on random number generation is the book "Numerical Recipes in C". It contains a very good discussion on how one can create different distributions based on a uniform random deviate.\
\
\
\
Strings\
\
Q:What types of strings are there?\uc0\u8232 \u8232 A:\u8232 - char*: this is also called a C-style string, or an ANSI string.\u8232 \u8232 - wchar_t*: this is wide character string, i.e. an unsigned short *\u8232 \u8232 - CString: this is a string wrapper class, which is part of the Microsoft Foundation Classes(MFC).\u8232 \u8232 - std::string: this is a Standard C++ Class wrapping a char string. It is part of the Standard Template Library, or STL.\u8232 \u8232 - std::wstring: this is a Standard C++ Class wrapping a wchar_t string. It is part of the Standard Template Library, or STL.\u8232 \u8232 - BSTR: this known as basic string or binary string, and is a pointer to a wide character string used by Automation data manipulation functions.\
Q:\uc0\u8232 What is the difference between \\n and \\r\\n ? Should I be concerned about the differences ?\u8232 What types of characters indicate a new line ?\u8232 \u8232 A:\u8232 \u8232 Background\u8232 \u8232 There are a few characters which can indicate a new line. The usual ones are these two:\
\
"\\n" or 0x0A (10 in decimal)\uc0\u8232 This character is called "Line Feed" (LF).\
"\\r" or 0x0D (13 in decimal)\uc0\u8232 This one is called "Carriage return" (CR)\
\uc0\u8232 \u8232 Different Operating Systems handle newlines in a different way. Here is a short list of the most common ones:\
\
DOS and Windows\uc0\u8232 They expect a newline to be the combination of two characters, namely "\\r\\n" (or 13 followed by 10).\
Unix (and hence Linux as well)\uc0\u8232 Unix uses a single "\\n" to indicate a new line.\
Mac\uc0\u8232 Macs use a single "\\r".\
\uc0\u8232 \u8232 This difference gives rise to a number of problems. For example, a file created under Unix (so with newlines as a single LF) will not open correctly under Window's Notepad. Any Windows program that expects newlines to be CRLF will not work correctly with these files.\u8232 \u8232 To unify things a bit, so that writing portable C/C++ programs is possible, file streams have both a "translated" and an "untranslated" mode. If you open a file in translated mode, the runtime library will convert a "\\n" to the appropriate newline character(s). If the following program is compiled under Unix, the file will contain a single LF to indicate the newline. If it's compiled under windows, it will contain a CRLF.\
code:\
\
\
#include \
#include \
\
int main()\
\{\
  FILE *fp = fopen("testfile.txt", "w");\
  fprintf(fp, "Hello World\\n");\
  fclose(fp);\
  return 0;\
\}\
\
\uc0\u8232 \u8232 If you look at the generated file with a hex editor, you will see that the windows version has generated the following:\
code:\
\
\
  H    e    l    l    o         W    o    r    l    d   CR   LF\
0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x0D 0x0A\
\
\uc0\u8232 \u8232 So file streams are handled in a transparent way, provided of course that you only handle files compatible with your operating system. But many times you have to pass multi-line strings directly to some system functions. \u8232 \u8232 In practice\u8232 \u8232 In Windows you have to pass multi-line strings with \\r\\n, otherwise the system functions don't recognize them correctly as multi-line. This is true e.g. for setting the text of Edit controls, Labels, Windows etc. Also, when you read multi-line text from a file that initially contains "\\r\\n" in translated mode, the string in memory will contain only a single "\\n". See for example the documentation on MSDN about fread:\
quote: \
\
MSDN\uc0\u8232 The fread function reads up to count items of size bytes from the input stream and stores them in buffer. The file pointer associated with stream (if there is one) is increased by the number of bytes actually read. If the given stream is opened in text mode, carriage return\'96linefeed pairs are replaced with single linefeed characters. The replacement has no effect on the file pointer or the return value. The file-pointer position is indeterminate if an error occurs. The value of a partially read item cannot be determined.\
\
\uc0\u8232 \u8232 If you want to be able to read text files written on different operating systems, you have to open the file in binary (= untranslated) mode and check for the different newlines yourself.\
\
\
Q: How to use CString in non-MFC applications?\uc0\u8232 \u8232 A:\u8232 In most cases, you don't need to do that. In order to use CString you have to statically or dynamically link your application to the entire MFC. This would not only increase the size of your executable file, the number of its dependencies, but also makes your program non-portable (especially if it is a Console application).\u8232 \u8232 The recommended solution is to use the Standard C++ Class std::string. It is as powerfull as CString, is portable, using it does not imply adding a huge amount of things you don't need to your project and last, but not least, it is part of the programming language.\u8232 \u8232 \u8232 \u8232 This being said, if you still want to use CString in your non-MFC application, here it is whar you have to do:\u8232 \u8232 - Include <afx.h> in one of your main headers;\u8232 \u8232 - Open the menu "Project", submenu "Settings". On the "General" tab of the settings dialog box choose "Use MFC in a Shared DLL" or "Use MFC in a Static Library" from the dropdown called "Microsoft Foundation Classes".\u8232 \u8232 - Rebuild your project.\u8232 \u8232 A simple sample of a Console application using CString looks like this:\
code:\
\
\
#include <afx.h>\
#include <iostream>\
int main()\
\{\
   CString s("Hello");\
   std::cout<<s.GetBuffer(0)<<std::endl;\
   return 0;\
\}\
\
\
\
Q: How to convert between ANSI and UNICODE strings?\uc0\u8232 \u8232 A:\u8232 This answers were inspired by a  HYPERLINK "http://www.codeguru.com/forum/showthread.php?s=&postid=594418& highlight=To+convert+an+ANSI+string+to+Unicode+use<br />" \\l "post594418" reply posted by  HYPERLINK "http://www.codeguru.com/forum/member.php?s=&action=getinfo&userid=81047" Yves M\u8232 \u8232 \u8232 \u8232 The quick and dirty way \u8232 This way of working is correct for codepages that are single-byte and Unicode strings that are UCS2. This applies to most cases, but if your program should run correctly on Japanese, Chinese, Taiwanese and other systems which have DBCS codepages then use the "correct way" described further below.\u8232 \u8232 ANSI to UNICODE:\u8232 The conversion is done using the MultiByteToWideChar() function:\
code:\
\
\
   char *ansistr = "Hello";\
   int a = lstrlenA(ansistr);\
   BSTR unicodestr = SysAllocStringLen(NULL, a);\
   MultiByteToWideChar(CP_ACP, 0, ansistr, a, unicodestr, a);\
   //... when done, free the BSTR\
   SysFreeString(unicodestr);\
\
\uc0\u8232 \u8232 UNICODE to ANSI:\u8232 The UNICODE string mostly is returned by some COM function, like this one:\
code:\
\
\
HRESULT SomeCOMFunction(BSTR *bstr)\
\{\
   *bstr = ::SysAllocString(L"Hello");\
   return S_OK;\
\}\
\
\uc0\u8232 The conversion is done using the WideCharToMultiByte() function:\
code:\
\
\
  BSTR unicodestr = 0;\
  SomeCOMFunction(&unicodestr);\
  int a = SysStringLen(unicodestr)+1;\
  char *ansistr = new char[a];\
  WideCharToMultiByte(CP_ACP, \
                        0, \
                        unicodestr, \
                        -1, \
                        ansistr, \
                        a, \
                        NULL, \
                        NULL);\
  //...use the strings, then free their memory:\
  delete[] ansistr;\
  SysFreeString(unicodestr);\
\
\uc0\u8232 \u8232 The correct way\u8232 If you want to handle DBCS codepages and UTF-16 Unicode strings then you should do things this way. The idea is to call MultiByteToWideChar resp. WideCharToMultiByte twice. First you get the length of the result, then you allocate the resulting string and call it again to convert.\u8232 \u8232 ANSI to Unicode\
code:\
\
\
  char *ansistr = "Hello"\
  int lenA = lstrlenA(ansistr);\
  int lenW;\
  BSTR unicodestr;\
\
  lenW = MultiByteToWideChar(CP_ACP, 0, ansistr, lenA, 0, 0);\
  if (lenW > 0) \{ // Check whether conversion was successful\
    unicodestr = SysAllocStringLen(0, lenW);\
    MultiByteToWideChar(CP_ACP, 0, ansistr, lenA, unicodestr, lenW);\
  \} else \{\
    // handle the error\
  \}\
  // when done, free the BSTR\
  SysFreeString(unicodestr);\
\
\uc0\u8232 \u8232 Unicode to ANSI\
code:\
\
\
  BSTR unicodestr = 0;\
  char *ansistr;\
  SomeCOMFunction(&unicodestr);\
  int lenW = SysStringLen(unicodestr);\
  int lenA = WideCharToMultiByte(CP_ACP, 0, unicodestr, lenW, 0, 0, NULL, NULL);\
  if (lenA > 0) \{\
    ansistr = new char[lenA + 1]; // allocate a final null terminator as well\
    WideCharToMultiByte(CP_ACP, 0, unicodestr, lenW, ansistr, lenA, NULL, NULL);\
    ansistr[lenA] = 0; // Set the null terminator yourself\
  \} else \{\
    // handle the error\
  \}\
  //...use the strings, then free their memory:\
  delete[] ansistr;\
  SysFreeString(unicodestr);\
\
\
\
Q: How to assign or compare strings?\uc0\u8232 \u8232 A:\u8232 Assignment and comparison are not necessarily related, but we decided to handle them together because the mistakes made by programmers beginning with C++ have a common root, that is, the tendence to use a "natural" syntax.\u8232 \u8232 \u8232 Assignment\u8232 \u8232 This actually is an issue only when working with C-style strings, i.e. char *. The most common mistake is this:\
code:\
\
\
   char *s1, *s2;\
   //...\
   s2 = s1; // might not do what one would think\
\
\uc0\u8232 This statement assignes to the char pointer s2 the same vale as s1. With other words, s1 and s2 will point to one and the same address in memory. By no means is the string s1 points to copied into s2.\u8232 \u8232 Another mistake that is frequently made by beginners is something like this:\
code:\
\
\
   char *s = "Hello";\
   s[1] = 'a'; // attempting to change the 'e' to an 'a'\
   //...\
\
\uc0\u8232 Chances are to get an access violation when running this snip of code. The reason is that, again, the assignment applies to the char pointer s, i.e. it will point to the address of the constant string literal "Hello". Since the compiler is allowed to place such const literals in read-only memory, attempting to modify it has undefined results.\u8232 \u8232 The correct solution is to use the strcpy() function or one of its relatives.\
code:\
\
\
   char *s;\
   s = new char[strlen("Hello")+1]; // reserve one byte for \
                                    // the trailing '/0'\
   strcpy(s, "Hello");\
   //...\
   delete[] s;\
\
\uc0\u8232 Both CString and the Standard C++ Class std::string are "user-friendly" and take care by themselves of this details. This code is perfectly ok:\
code:\
\
\
#include <string>\
//...\
   std::string s;\
   s = "Hello";\
   s[1] = 'a';\
\
\uc0\u8232 Comparison\u8232 \u8232 This also is an issue only when working with C-style strings, i.e. char *. The most common mistake is this:\
code:\
\
\
   char *s1, *s2;\
   // ...\
   if(s1 == s2) .... // wrong!!!!\
\
\uc0\u8232 This statement may seem to be the natural syntax, but it unfortunately compares the value of two char pointers and by no means the strings they point to. \u8232 To compare C-style strings you have to use the strcmp() function or one of its relatives:\
code:\
\
\
   char *s1, *s2;\
   //...\
   if(!strcmp(s1, s2))....\
\
\uc0\u8232 Note that strcmp() returns 0 if the strings are identical, thus the !strcmp(...) in the if statement. Have a look in MSDN for further details on strcmp() and other string comparison functions.\u8232 \u8232 \u8232 Both CString and the Standard C++ Class std::string have overloaded comparison operators, which leads to a more natural syntax:\
code:\
\
\
#include <string>\
//...\
   std::string s1, s2;\
   //...\
   if(s1 == s2) ....\
\
\uc0\u8232 All this being said, it should be clear why you always should prefere working with a string wrapper class over working with C-style strings. And there is much more std::string can do for you than this!\
\
\
Q: What is the difference between CString and std::string? Can I mix them?\uc0\u8232 \u8232 A: CString is a MFC class and can be used only for Windows programs that are staticaly or dynamically linked to the MFC. Use CStrings when you write MFC programs.\u8232 \u8232 std::string is a Standard C++ Class - in other words, it is part of the C++ programming language. It is a very powerfull class that can be used in any kind of Windows programs (MFC, Win32, Win32 Console) as well as in non-Windows programs.\u8232 \u8232 CStrings and std::strings can be mixed, if you know what you are doing and you take some precautions.\
\
Q: How to get the hex representation of a ... into a string?\uc0\u8232 \u8232 A:\u8232 There are two common scenarios: wanting a string containing the hex representation of \u8232 some built-in type variable, like an int or a float or wanting the hex \u8232 representation of every byte from a string.\u8232 \u8232 \u8232 Built-in types\u8232 \u8232 Following template function can be used on the built-in types:\
code:\
\
\
template <class T>\
CString VariableToHexString(T t)\
\{\
   CString ret, tmp;\
   for(int i = sizeof(T)-1; i>=0; i--)\{\
      unsigned char c = \
           reinterpret_cast<unsigned char *>(&t)[i];\
      tmp.Format(" %02hX", c);\
      ret+=tmp;\
   \}\
   return ret;\
\}\
//...\
// Following call\
   AfxMessageBox(VariableToHexString<int>(12345678), \
                 MB_OK,\
                 0);\
// produces a message box containing "00 BC 61 4E"\
\
\uc0\u8232 We also provide another  HYPERLINK "http://www.codeguru.com/forum/showthread.php?s=&threadid=231054" solution that uses Standard C++ Classes.\u8232 \u8232 \u8232 Strings\
code:\
\
\
CString StringToHexString(CString cs)\
\{\
   CString ret, tmp;\
   for(int i=0; i<cs.GetLength(); i++)\{\
      unsigned char c = cs[i];\
      tmp.Format(" %02hX", c);\
      ret+=tmp;\
   \}\
   return ret;\
\}\
// Following call\
   AfxMessageBox(StringToHexString("Hello"), MB_OK, 0);\
// produces a message box containing "48 65 6C 6C 6F"\
\
\
\
Q: How to convert between a CString and a BSTR?\uc0\u8232 \u8232 A:\u8232 CString to BSTR:\u8232 \u8232 Use the AllocSysString member function of the CString:\
code:\
\
\
   CString cs("Hello");\
   BSTR bstr = cs.AllocSysString();\
\
\uc0\u8232 If you pass the BSTR to some OLE function, this will normally free the BSTRs memory when done with it.\u8232 \u8232 If you use the BSTR by yourself, dont forget to call ::SysFreeString() when you're done with it.\
code:\
\
\
   ::SysFreeString(bstr);\
\
\uc0\u8232 BSTR to CString:\u8232 \u8232 You will mostly need this when you have some OLE function that returns a BSTR. Such an OLE Function will basicly do something like\u8232 this:\
code:\
\
\
HRESULT SomeOLEFunction(BSTR &bstr)\
\{\
   bstr = ::SysAllocString(L"Hello");\
   return S_OK;\
\}\
\
\uc0\u8232 Use a temporary variable of the type _bstr_t to wrap the BSTR. This way you handle both the 208 \u8232 and make sure that you have no memory leak:\
code:\
\
\
   BSTR bstr;\
   SomeOLEFunction(bstr);\
   _bstr_t tmp(bstr, FALSE); //wrap the BSTR\
   CString cs(static_cast<const char *>(tmp)); //convert it\
   AfxMessageBox(cs, MB_OK, 0); //test \
   // when tmp goes out of scope it will free the BSTRs memory\
\
\uc0\u8232 Note that this won't work in a UNICODE build.\
\
\
\
Q: How to convert between CString and std::string?\uc0\u8232 \u8232 A:\u8232 CString to std::string:\
code:\
\
\
   CString cs("Hello");\
   std::string s((LPCTSTR)cs);\
\
\uc0\u8232 std::string to CString:\
code:\
\
\
   std::string s("Hello");\
   CString cs(s.c_str());\
\
\
\
Q: How to convert a char* to CString?\uc0\u8232 \u8232 A:\u8232 Use either the constructor of CString, or its = operator:\
code:\
\
\
   char *str = "Hello";\
   CString cs(str);\
   // or\
   CString cs;\
   cs = str;\
\
\
Q: How to convert a CString to a char*?\uc0\u8232 \u8232 A:\u8232 You will need this mostly to pass a CString to a function that expects a char*. \
code:\
\
\
   // Prototype of a function expecting a char*:\
   void Foo(char *c);\
   //...\
   CString csMyString = "Hello World";\
   //...now call Foo():\
   char *str = csMyString.GetBuffer(csMyString.GetLength());\
   Foo(str);\
   // or directly:\
   Foo(csMyString.GetBuffer(csMyString.GetLength()));\
   // if Foo modifies the passed char*, you must call\
   csMyString.ReleaseBuffer(-1);\
\
\uc0\u8232 Notes:\u8232 \u8232 a) CString::GetBuffer() will return a char* only in non-UNICODE builds. \u8232 \u8232 b) CString has an implicit 208 operator to LPCTSTR. In non-UNICODE builds, that is a const char*. Do not use a cast hack like\u8232 this:\
code:\
\
\
   Foo((char *)((LPCSTR)csMyString)); // BAD!!!!\
\
\uc0\u8232 c) Do not call any other CString member function on csMyString between GetBuffer() and ReleaseBuffer().\
\
Strings: How to convert a numeric type to a string? \
The ol' C method (deprecated) \
code:\
\
\
   char *c[10]; // simply large enough - don't forget the \
                // extra byte needed for the trailing '/0' \
   int i = 1234;\
   sprintf(c, "%d", i);\
\
\uc0\u8232 See sprintf() in MSDN for further details.\u8232 \u8232 Using CString \
code:\
\
\
   int i = 1234;\
   CString cs;\
   cs.Format("%d", i);\
\
\uc0\u8232 The format specifiers are the same as for sprintf(). See the CString documentation in MSDN - it is fairly straight forward.\u8232 A word of warning: mismatching the format specifiers ("%d") and the actually passed parameters will lead to unpredictable results, both for sprintf() and for CString::Format().\u8232 \u8232 The C++ way:\u8232 Following sample shows a template function that uses Standard C++ Classes to complete the task: \
code:\
\
\
#include <string>\
#include <sstream>\
#include <iostream>\
\
template <class T>\
std::string to_string(T t, std::ios_base & (*f)(std::ios_base&))\
\{\
   std::ostringstream oss;\
   oss << f << t;\
   return oss.str();\
\}\
\
int main()\
\{\
   // the second parameter of to_string() should be one of \
   // std::hex, std::dec or std::oct\
   std::cout<<to_string<long>(123456, std::hex)<<std::endl;\
   std::cout<<to_string<long>(123456, std::oct)<<std::endl;\
   return 0;\
\} \
\
/* output:\
1e240\
361100\
*/\
\
\uc0\u8232 This method is not only very elegant, but also type safe, because the compiler will pick\
\
Strings: How to convert a string into a numeric type? \
There is one thing that you are not allowed to ignore when you convert a string into a numeric\uc0\u8232 type: the conversion might fail because the \u8232 string you are convertnig might not contain a valid representation of a number.\u8232 If, for example, you try to convert the string "Hello" to a number, \u8232 the conversion must fail.\u8232 \u8232 \u8232 The ol' C way (deprecated):\u8232 \u8232 Many people use the atoi(), atof() and the other functions from this "family". They're easy to use but have a major\u8232 drawback: they return 0 both on failure and when converting the string "0", thus making a consistent error detection as good \u8232 as impossible. We give this little sample for the sake of completeness:\
code:\
\
\
   const char* str_int = "777";\
   const char* str_float = "333.3";\
   int i = atoi(str_int);\
   float f = atof(str_float);\
\
\uc0\u8232 A better way:\u8232 \u8232 A bit more complicated, but also more consistent way is to use sscanf() in one of it's flavors:\
code:\
\
\
   const char* str_int = "777";\
   const char* str_float = "333.3";\
   int i;\
   float f;\
   if(EOF == sscanf(str_int, "%d", &i))\{\
      //error\
   \}\
   if(EOF == sscanf(str_float, "%f", &f))\{\
      //error\
   \}\
\
\uc0\u8232 Since sscanf() takes a const char* parameter, you can directly use a CString with\u8232 it:\
code:\
\
\
   CString str_int("777");\
   if(EOF == sscanf(str_int, "%d", &i))\{\
      //error\
   \}\
\
\uc0\u8232 Be very careful with the format specifier (i.e. "%d" in this example). sscanf() has no way to check whether the format specifier \u8232 and the type of the passed variable match each other. If they don't you will get unexpected\u8232 results. Also note that sscanf() is able to extract more than one \u8232 numerical value from a string with one call. Have a look in MSDN for details.\u8232 \u8232 \u8232 The C++ way\u8232 \u8232 Following sample shows a template function that uses Standard C++ Classes to complete the\u8232 task:\
code:\
\
\
#include <string>\
#include <sstream>\
#include <iostream>\
\
template <class T>\
bool from_string(T &t, \
                 const std::string &s, \
                 std::ios_base & (*f)(std::ios_base&))\
\{\
   std::istringstream iss(s);\
   return !(iss>>f>>t).fail();\
\}\
\
int main()\
\{\
   int i;\
   float f;\
   // the third parameter of from_string() should be \
   // one of std::hex, std::dec or std::oct\
   if(from_string<int>(i, std::string("ff"), std::hex))\{\
      std::cout<<i<<std::endl;\
   \}\
   else\{\
      std::cout<<"from_string failed"<<std::endl;\
   \}\
   if(from_string<float>(f, \
                               std::string("123.456"),\
                               std::dec))\
   \{\
      std::cout<<f<<std::endl;\
   \}\
   else\{\
      std::cout<<"from_string failed"<<std::endl;\
   \}\
   return 0;\
\} \
\
/* output:\
255\
123.456\
*/\
\
\uc0\u8232 This method is not only elegant but also type safe, because the compiler will pick the proper std::istringstream::operator >>() at compile time, \u8232 according to the operand type.\
\
\
\
STL FAQ\
\
General\
\
Q: How can I define a dynamic two-dimensional array?\uc0\u8232 \u8232 A: The basic idea is to use a vector<vector<T> >. Use containment to write a template class that offers the desired functionality. Following skeleton code shows how to implement and use such a class:\
code:\
\
\
#include <vector>\
\
template <typename T>\
class dynamic_array\
\{\
public:\
    dynamic_array()\{\};\
    dynamic_array(int rows, int cols)\
    \{\
        for(int i=0; i<rows; ++i)\{\
            data_.push_back(std::vector<T>(cols));\
        \}\
    \}\
    // other ctors ....\
    std::vector<T> & operator[](int i)\
    \{\
        return data_[i];\
    \}\
    const std::vector<T> & operator[] (int i) const\
    \{\
        return data_[i];\
    \}\
    // other accessors, like at() ...\
\
	// other member functions, like reserve()....\
\
private:\
    std::vector<std::vector<T> > data_;\
    \
\};\
\
int main()\
\{\
    dynamic_array<int> a(3, 3);\
    a[1][1] = 2;\
    int x = a[1][1];\
    return 0;\
\}\
\
\
\
Q: What is the best way to remove all elements of a particular value from a container?\uc0\u8232 \u8232 A:\u8232 Use the so-called "remove/erase" idiom:\
code:\
\
\
// taken from Item 32 of Scott Myers' Effective STL\
vector v;\
v.erase(remove(v.begin(), v.end(), 99), v.end());\
\
\uc0\u8232 \u8232 This is because of the simple fact that remove() is a generic\u8232 algorithm which takes iterators as its arguments. The iterators\u8232 know nothing of their container; the STL was designed so as to\u8232 grant the smallest possible amount of coupling. Thus, the\u8232 iterators cannot call any container's "erase()" or similar function.\u8232 \u8232 remove() DOES return the container's new end() [which just\u8232 happens to be the first element that was removed] and this value\u8232 can be used in the container's erase() call.\
\
\
Q: I get the following warning when compiling the STL with MSVC. The code works fine though. Should I be worried? Am I doing something wrong?\uc0\u8232 \u8232 warning C4786: 'Some STL template class' : identifier was truncated to '255' characters in the debug information\u8232 \u8232 \u8232 A: No, you are not doing anything wrong, nor should you be worried. MSVC is just telling you that the name of the STL template class is very long and that it has truncated the name in the debug information only. In theory, this might cause possible collisions when attempting to debug applications, but in pratice this very, very seldom happens if ever.\u8232 \u8232 You can disable this warning by including the preprocessor directive:\
code:\
\
#pragma warning(disable:4786)\
\
\
\
\
Advanced\
\
Q: What is the meaning of the Alloc template parameter in std::vector ?\uc0\u8232 Q: How do I define my own allocator for use in STL containers?\u8232 \u8232 A: The whole concept is very well explained in  HYPERLINK "http://www.codeguru.com/cpp_mfc/allocator.html" \\t "_blank" Gabriel and Andreas' article about Allocators.\u8232 \u8232 The template parameter Alloc specifies the type of allocator that the container should use to manage its memory. Every time the container needs a bit of memory, it will ask the allocator to retrieve it for him. The allocator usually just calls new (and delete when it has to free memory), but there can be more sophisticated strategies for allocators.\u8232 \u8232 Usually, you are fine with the standard allocator provided by your STL. However, at times you may need to specify the allocation strategy explicitly. In theory, writing a custom allocator is not very difficult, but the task is complicated by the fact that the standard C++ design relies on template member functions which quite a few compilers don't support (e.g. Visual C++ 6).\u8232 \u8232 A simple example for an allocator which never frees memory is this code (note that you need a recent compiler to get this to work):\
code:\
\
\
#include \
\
const size_t TEST_SIZE = 10000;\
const double TIME_MULTIPLIER = 100.0;\
\
const size_t MAX_SIZE = (TEST_SIZE + 1) * 12;\
\
class MemoryPool\
\{\
  unsigned char  *m_data;\
  size_t      m_top;\
  int        m_refcount;\
public:\
  MemoryPool()\
  \{\
    m_data = new unsigned char[MAX_SIZE];\
    m_top = 0;\
    m_refcount = 0;\
  \}\
  ~MemoryPool()\
  \{\
    delete [] m_data;\
  \}\
  void AddRef()\
  \{\
    ++m_refcount;\
  \}\
  void *alloc_mem(size_t n)\
  \{\
    if ((MAX_SIZE - m_top) >= n) \{\
      size_t old_top = m_top;\
      m_top += n;\
      return m_data + old_top;\
    \} else \{\
      return 0;\
    \}\
  \}\
  void Release()\
  \{\
    if (--m_refcount == 0) \{\
      delete this;\
    \}\
  \}\
\};\
\
template <class T>\
class MyAlloc \{\
public:\
  // type definitions\
  typedef T        value_type;\
  typedef T*       pointer;\
  typedef const T* const_pointer;\
  typedef T&       reference;\
  typedef const T& const_reference;\
  typedef std::size_t    size_type;\
  typedef std::ptrdiff_t difference_type;\
\
  // rebind allocator to type U\
  template <class U >\
  struct rebind \{\
    typedef MyAlloc< U > other;\
  \};\
\
  // return address of values\
  pointer address (reference value) const \{\
    return &value;\
  \}\
  const_pointer address (const_reference value) const \{\
    return &value;\
  \}\
\
  /* constructors and destructor\
  * - nothing to do because the allocator has no state\
  */\
  MyAlloc() throw() \{\
    m_pPool = new MemoryPool;\
    m_pPool->AddRef();\
  \}\
  MyAlloc(const MyAlloc& src) throw() \{\
    m_pPool = src.m_pPool;\
    m_pPool->AddRef();\
  \}\
  template <class U >\
  MyAlloc (const MyAlloc< U > &src) throw() \{\
    m_pPool = src.m_pPool;\
    m_pPool->AddRef();\
  \}\
  ~MyAlloc() throw() \{\
    m_pPool->Release();\
  \}\
\
  // return maximum number of elements that can be allocated\
  size_type max_size () const throw() \{\
    return MAX_SIZE / sizeof(T);\
  \}\
\
  // allocate but don't initialize num elements of type T\
  pointer allocate (size_type num, const void* = 0) \{\
    // print message and allocate memory with global new\
    pointer ret = (pointer) m_pPool->alloc_mem(num * sizeof(T));\
    return ret;\
  \}\
\
  // initialize elements of allocated storage p with value value\
  void construct (pointer p, const T& value) \{\
    // initialize memory with placement new\
    new((void*)p)T(value);\
  \}\
\
  // destroy elements of initialized storage p\
  void destroy (pointer p) \{\
    // destroy objects by calling their destructor\
    p->~T();\
  \}\
\
  // deallocate storage p of deleted elements\
  void deallocate (pointer p, size_type num) \{\
    // do not deallocate memory\
  \}\
\
  MemoryPool  *m_pPool;\
\};\
\
// return that all specializations of this allocator are interchangeable\
template <class T1, class T2>\
bool operator== (const MyAlloc&, const MyAlloc&) throw() \{\
  return true;\
\}\
template <class T1, class T2>\
bool operator!= (const MyAlloc&, const MyAlloc&) throw() \{\
  return false;\
\}\
\
\
\
STL&MFC:\
\
Q: How can I sort a CArray (or CStringArray, CIntArray, etc.)?\uc0\u8232 \u8232 A: If the CxxxArray's items can be compared, then use std::sort:\u8232 \u8232 Ascending:\
code:\
\
\
#include <algorithm>\
//...\
CArray<int, int&> MyCArray;\
CStringArray MyStringArray;\
//...\
// Sort the CArray of ints\
std::sort( MyCArray.GetData(), \
           MyCArray.GetData() + MyCArray.GetSize());\
\
// Sort the CStringArray\
std::sort( MyStringArray.GetData(), \
           MyStringArray.GetData() + MyStringArray.GetSize());\
\
\uc0\u8232 Descending: You need to supply a comparison function.\
code:\
\
#include <algorithm>\
//...\
bool SortDescendingInt(const int& x, const int& y)\
\{\
   return x > y;\
\}\
\
bool SortDescendingString( const CString& s1, \
                           const CString& s2)\
\{\
   return s1 > s2;\
\}\
\
CArray<int, int> MyCArray;\
CStringArray MyStringArray;\
//...\
// Sort the CArray of ints\
std::sort( MyCArray.GetData(), \
           MyCArray.GetData() + MyCArray.GetSize(), \
           SortDescendingInt);\
\
// Sort the CStringArray\
std::sort( MyStringArray.GetData(), \
           MyStringArray.GetData() + MyStringArray.GetSize(),\
           SortDescendingString);\
\
\
\
Windows programming\uc0\u8232 \u8232 General:\
\
\
STL\
The Standard Template Libraries (STL's) are a set of C++ template classes to provide common programming data structures and functions such as doubly linked lists (list), paired arrays (map), expandable arrays (vector), large string storage and manipulation (rope), etc. The STL library is available from the  HYPERLINK "http://www.sgi.com/tech/stl/" STL home page. This is also your best detailed reference for all of the STL class functions available. \
STL can be categorized into the following groupings: \
\
STL can be categorized into the following groupings: \
Container classes: \
Sequences: \
 HYPERLINK "http://www.yolinux.com/TUTORIALS/LinuxTutorialC++STL.html" \\l "VECTOR" vector: (this tutorial) Dynamic array of variables, struct or objects. Insert data at the end. \uc0\u8232 (also see the  HYPERLINK "http://www.yolinux.com/TUTORIALS/CppBoostStlPtrList.html" YoLinux.com tutorial on using and STL list and boost ptr_list to manage pointers.) \
deque: Array which supports insertion/removal of elements at beginning or end of array \
 HYPERLINK "http://www.yolinux.com/TUTORIALS/LinuxTutorialC++STL.html" \\l "LIST" list: (this tutorial) Linked list of variables, struct or objects. Insert/remove anywhere. \
Associative Containers: \
set (duplicate data not allowed in set), multiset (duplication allowed): Collection of ordered data in a balanced binary tree structure. Fast search. \
 HYPERLINK "http://www.yolinux.com/TUTORIALS/CppStlMultiMap.html" map (unique keys),  HYPERLINK "http://www.yolinux.com/TUTORIALS/CppStlMultiMap.html" \\l "MULTIMAP" multimap (duplicate keys allowed): Associative key-value pair held in balanced binary tree structure. \
Container adapters: \
stack LIFO \
queue FIFO \
priority_queue returns element with highest priority. \
String: \
 HYPERLINK "http://www.yolinux.com/TUTORIALS/LinuxTutorialC++StringClass.html" string: Character strings and manipulation \
rope: String storage and manipulation \
bitset: Contains a more intuitive method of storing and manipulating bits. \
Operations/Utilities: \
iterator: (examples in this tutorial) STL class to represent position in an STL container. An iterator is declared to be associated with a single container class type. \
algorithm: Routines to find, count, sort, search, ... elements in container classes \
auto_ptr: Class to manage memory pointers and avoid memory leaks. \
\
\
}{\*\shppict {\pict \jpegblipPageWidth pageWidth = 432.000000}}{\*\shppict {\pict \jpegHeaderFooterString headerStyle = 0, headerPageFormat = 0, headerStartNumber = 0, headerIncludeNumberOnFirstPage = 0, footerStyle = 0, footerPageFormat = 0, footerStartNumber = 0, footerIncludeNumberOnFirstPage = 0,}}